# Vue2 笔记

## 02.基础概念

1. 什么是 MVVM(面试题!!!!!)

- MVVM 是一个软件架构的设计模式,vue 的设计遵循了 MVVM 模式

- MVVM 分为三个部分：分别是 M（Model，模型层 ），V（View，视图层），VM（ViewModel，视图数据层,V 与 M 连接的桥梁，也可以看作为控制器）

  - M：模型层，值得是数据模型,主要负责业务数据相关；

  - V：视图层，顾名思义，负责视图相关，细分下来就是 html+css 层,为了更方便的展示 Model 层的数据；

  - VM：V 与 M 沟通的桥梁，负责监听 M 或者 V 的修改，是实现 MVVM 双向绑定的要点

- ViewModel 是 Vue.js 的核心，它是一个 Vue 实例,MVVM 支持双向绑定，意思就是当 M 层数据进行修改时，VM 层会监测到变化，并且通知 V 层进行相应的修改，反之修改 V 层则会通知 M 层数据进行修改

2. 实例化 Vue 时的 el 配置项

- 提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。

- 可以是 CSS 选择器(字符串)，也可以是一个 HTMLElement 实例

- 在实例挂载之后，元素可以用 vm.$el 获取 Vue 实例使用的根 DOM 元素

3. 实例化 Vue 时的 template 配置项:

- Vue 实例使用一个字符串作为模板,使用 template 配置项

- 模板将会替换挂载的容器元素。挂载元素的内容都将被忽略

- 其他写法:在 vue 执行中会判断有没有 template 配置项:

  1. 如果有则编译当前的 template 配置项的字符串替换容器

  2. 如果没有,则把 el 容器的 outerHTML 作为模板编译

4. 实例化 Vue 时 vm 对象的$mount 方法

- 如果 Vue 实例在实例化时没有收到 el 选项，则它处于“未挂载”状态，没有关联的 DOM 元素。

- 可以使用 vm.$mount(element|Selector) 手动地挂载一个未挂载的实例

- 这个方法返回实例自身，因而可以链式调用其它实例方法。

5. vue 的 data 配置项:

- Vue 实例的数据对象

- 当 Vue 在实例化的时候遇到了 data 数据配置项,就会把 data 对象中的数据放在 vm 实例的\_data 属性上,如果需要使用某个数据那么就需要使用 vm.\_data.xxxxx 来操作

- 为了方便操作,数据会在 vm 上也存放一份,可以 vm.xxx 直接使用,操作 vm 上的数据其实内部就是在操作\_data 里的数据(数据代理)

- 实例创建之后，可以通过 vm.$data 或者 vm.\_data 访问原始数据对象。Vue 实例也代理了 data 对象上所有的属性,因此访问 vm.a 等价于访问 vm.\_data.a

6. vue 中 data 配置项为什么要写成一个函数??(常见面试题!!!!!)

- 当一个组件被定义，data 必须声明为返回一个初始数据对象的函数

- 因为组件可能被用来创建多个实例。如果 data 仍然是一个纯粹的对象，则所有的实例将共享引用同一个数据对象！

- 通过提供 data 函数，每次创建一个新实例后，我们能够调用 data 函数，从而返回初始数据的一个全新副本数据对象。

7. Vue 模板中的插值语法:

- 插值语法主要用在模板标签的内容区域引入 js 表达式使用(!!!在模板标签的属性区域是不能使用的)

- Vue 的插值语法使用双大括号呈现({{}})

- Vue 的插值语法主要可以书写 3 种内容

  - 直接书写一个值

  - 书写一个【实例上！！！！！】的属性 或 方法调用

  - 书写一个表达式(会返回一个值)

- 插值中各种类型值的转换规则:除了 undefined 和 null 转为空串以外,其他类型都是正常转为字符串

## 03.指令系统

1. v-on:绑定事件

- 绑定事件的基础使用

  - 可以用 v-on 指令监听 DOM 事件，并接受一个在 methods 配置项中定义的函数作为事件函数

  - 事件函数书写在 methods 配置项中,Vue 保证你可以在函数中 this 指向 vue 实例,从而拿到数据

- 事件函数的传参

  - 在绑定事件的时候,直接给事件函数传递参数

  - 在 methods 中定义的事件函数直接书写形参接受参数

  - 不需要书写高阶函数处理参数的情况(因为我们在 v-on 的插值中书写 fn() 其实是事件简写的代码片段写法)

- event 事件对象

  - 如果调用事件函数没有传参(没有加小括号),则事件函数中的第一个参数就是 event 事件对象,直接接受即可

  - 在 v-on 指令后的插值语法中默认存在一个$event的数据,代表当前的event事件对象,如果事件函数需要显示传参,我们就可以找一个位置把$event 显式传递进去

- 简写:

  - `v-on:`指令可以直接简写为@

  - 如果事件函数内部的逻辑简单,并且只是操作数据,则可以直接在 v-on 后的插值语法中书写 js 片段,不需要书写函数

- 事件修饰符

  - prevent:阻止默认事件

  - stop:阻止传播

  - capture:默认绑定的事件都是在冒泡阶段执行,添加 capture 修饰符可以设置捕获阶段执行

  - self:只有事件的 e.target 是当前元素的时候才会出发当前元素上的事件

  - once:当前事件只能执行一次

  - 键盘修饰符:比如按键为回车键才触发的：@keyup.13="keyup" 或者 @keyup.enter="keyup"

2. v-bind 强制绑定

- 基础使用

  - `v-bind`:vue 中提供的用于对模板中的属性进行强制绑定的指令

  - `v-bind`指令后的属性值区域就是插值语法区域

  - `v-bind:attr="xxx"`:给 attr 属性强制绑定 xxx 数据

  - `v-bind`可以简写为一个 :(冒号),比如`:attr="xxx"`

- 动态类名:写法为: `:class="xxx"` xxx 可以是字符串、对象、数组。

  - 字符串写法适用于：类名不确定是否添加,可以使用三元判断控制展示的是哪些字符串格式的类名(常用一个类名的操作)

  - 对象写法适用于：要绑定多个类名个数确定，类名也确定，但不确定用不用

  - 数组写法适用于：要绑定的类名，个数不确定、类名也不确定

- 动态 style:

  - `v-bind:style` 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。

  - CSS property 名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名`<div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>`

  - `:style="arr"`:arr 可以是包含样式对象的数组。当有多个样式对象的时候,可以使用数组整合

3. v-model 数据双向绑定

- 基础使用

  - 数据单向绑定（v-bind）：数据只能从 data 流向页面

  - 数据双向绑定：数据既能从 data 流向页面，也能从页面流向 data

  - 一般都是对可输入性的表单元素进行双向绑定,用来控制表单展示内容,和收集表单数据

- v-model 本质:

  - 对于输入性文本框，就是 `:value + @input`的语法糖，比如 `<input type="text" :value="xxx" @input="xxx=$event.target.value" />`

  - 对于单选框多选框等，就是 `:checked + @change`的语法糖

  - 对于下拉列表，就是 `:value + @change`的语法糖

- 收集表单数据

  - 输入文本框:使用字符串收集

  - 多选框多选状态:使用数组收集

  - 多选框单选状态:使用布尔值收集

  - 单选框:使用字符串收集

  - 下拉列表单选:使用字符串收集

  - 下拉列表多选:使用数组收集

  - 多行文本框:使用字符串收集

- 修饰符

  - .lazy - 取代 input 监听 change 事件

  - .number - 输入字符串转为有效的数字(和 parseInt 类似,但是无法转为 number 的时候,直接输出原字符串)

  - .trim - 输入首尾空格过滤

4. 条件渲染-v-if/v-else/v-else-if:

- `v-if`指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 truthy 值(转为 boolean 都是 true 的值)的时候被渲染。

- 可以使用 `v-else` 指令来表示 v-if 的“else 块”,v-else 元素必须紧跟在带 v-if 或者 v-else-if 的元素的后面，否则它将不会被识别。

- `v-else-if`，顾名思义，充当 v-if 的“else-if 块”，可以连续使用

- 在 `<template>` 元素上使用 v-if 条件渲染分组,最终的渲染结果将不包含 <template> 元素

5. 条件渲染 v-show:

- v-show 也是控制元素的显示和隐藏,接受一个布尔值,判断是显示还是隐藏

- 不同的是带有 v-show 的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS 的 display 属性

- v-show 不能在`<template>`元素上使用

6. v-if&&v-show 对比(!!!!!!!高频面试题)

- v-if 是“真正”的条件渲染，因为它会确保在切换过程中元素被销毁和重建。

- v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。

- 相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。

- 一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好;如果在运行时条件很少改变，则使用 v-if 较好。

7. 列表渲染

- 基于源数据多次渲染元素或模板块。此指令之值，必须使用特定语法 `item,index in data` 或者 `item,index of data`

- item 和 index 都是属于当前列表块内部的数据,在列表块内部可以直接使用

- item 是每次遍历出来的值,index 是当前值的下标

- v-for 一定要在列表渲染的元素上添加 key 属性,用户优化 diff 算法,并且不建议 key 使用 index 下标

- 类似于 v-if，你也可以利用带有 v-for 的 <template> 来循环渲染一段包含多个元素的内容。

- v-for 可以遍历数组,对象,字符串,数字等等数据格式

8. 其他指令

- v-text 和 v-html

  - v-text:更新元素的 textContent. 如果要更新部分的 textContent，需要使用 `{{  }} 插值`

  - v-html:更新元素的 innerHTML。注意：内容按普通 HTML 插入 - 不会作为 Vue 模板进行编译。如果试图使用 v-html 组合模板，可以重新考虑是否通过使用组件来替代

- v-once

  - v-once 不需要表达式

  - 只编译元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。

- v-pre

  - 不需要表达式

  - 跳过这个元素和它的子元素的编译过程。可以用来显示原始插值语法。跳过大量没有指令的节点会加快编译

- v-cloak

  - 这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 插值 标签直到实例准备完毕。

  - 在简单项目中，使用 v-cloak 指令是解决屏幕闪动的好方法。但在大型、工程化的项目中（webpack、vue-router）只有一个空的 div 元素，元素中的内容是通过路由挂载来实现的，这时我们就不需要用到 v-cloak 指令。

## 04.响应式修改 vue 的数据

1. 什么是响应式

- 响应式:当数据修改的时候,视图也会发生更新,我们称作为响应式

2. 修改数据方式 1:值是一个基本类型

- 基本类型的数据，包括 number boolean bigInt string 等

- 修改这类型的数据，我们可以直接重新赋值(不管数据的值是哪一种类型,只要是替换就拥有响应式!!!)，vue 能监听到数据发生的变化，然后对 DOM 作出修改。也就是具有响应式

2. 修改数据方式 2:修改数组类型值

- 直接通过下标修改数组:是不具备响应式的

- 通过修改 length 来修改数据:是不具备响应式的

- 使用数组的变更方法修改数组的值

  - 修改原数组方式(变更方法)如下:push pop shift unshift sort reverse splice,Vue 将数组的变更方法进行了包裹重写，所以它们也将会触发视图更新

- 返回新数组:则可以直接替换原来的数组也是具有响应式的

3. 修改数据方式:修改对象数据类型

- 操作对象类型的方式 1:直接替换对象的属性值,具有响应式

- 操作对象类型的方式 2:新增属性,不具备响应式,所以初始化数据的时候要把所有的属性都预先设置出来,不要将来去新增

- 操作对象类型的方式 3:删除属性 不具备响应式

- 操作对象类型的方式 4:直接替换对象的值,具备响应式

4. set 和 delete 方法

- 因为 vue2 响应式原理的底层原理无法监听对象的删除和新增

- vue2 新提供了两个方法,可以响应式的新增和删除对象的属性(Vue.set()和 Vue.delete() 或者 this.$set()和this.$delete())

## 05.计算属性和 watch

1. 计算属性(computed)

- 什么是计算属性

  - 得到一个响应式数据,只不过数据是通过计算得到的

  - 计算属性配置在 computed 配置项中

- 计算属性的写法

  - 计算属性只读:只需要写成一个函数,把最终计算的值返回出来即可

  - 计算属性可读可写:计算属性可以设置 getter 和 setter 函数,进行可读可写操作,setter 函数接受的参数就是新设置的值

- 计算属性和其他方式对比

  - 计算属性 vs 方法:方法只要调用就会重新求值,方法多次调用没有缓存

  - 计算属性 vs 插值语法中书写逻辑:臃肿,不方便识别是什么功能

  - 计算属性优点:计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值

2. watch(侦听器)

- 作用:监听一个 data 数据或者一个计算属性值的改变,他只负责监听,后续操作由业务逻辑决定

- watch 的基础写法:

  - 在 watch 配置项中监听某个响应式数据,并书写为一个函数

  - 当被监听的响应式数据发生变化的时候,则执行对应的函数

- watch 的完整用法:watch 监听一个值,书写为一个对象

  - watch 可以配置立即监听(immediate)

  - watch 可以设置深度监听(deep),如果值是一个对象,则内部属性改变的时候,也不会监听到

  - watch 的回调函数 handler,接受两个参数(newValue,oldValue),但是如果监听的是对象,则新值和旧值是一样的

- watch 怎么监听一个对象的属性

  - 使用`["xx.xx"](){}`

  - 使用`"xx.xx"(){}`

- watch 如果同时侦听多个属性

  1. computed 可以同时监听多个属性的变化,并重新计算值,我们可以让计算属性返回一个对象,包含所有监听的属性,一旦监听的属性发生改变,则 computed 就会重新计算得到新属性值

  2. 深度监听刚才的计算属性,只要计算属性内部有任何的变化,watch 都可以侦听到了

3. watch 和 computed 区别(!!!高频面试题!!!)

- computed 和 watch 都可以监听数据的变化,并进行下一步的处理

- computed 计算属性,会根据监听的数据进行计算,侧重于得到一个值!!!并且如果依赖项不发生变化,每次获取计算属性的值都会直接读取缓存

- watch 侦听属性,侧重于侦听一个属性值的改变,并在这个值变化的时候触发侦听函数,执行下一步的逻辑

4. v-for 和 v-if 一起使用

- 永远不要把 v-if 和 v-for 同时用在同一个元素上。

  1. v-for 的优先级大于 v-if,在编译阶段先 v-for 生成多个虚拟 DOM,然后再 v-if 去掉多个虚拟 DOM,造成性能浪费

  2. v-for 和 v-if 一起使用 可能结果预期不明确

- 以上问题的解决方案:

  1. 写一个计算属性,让其返回过滤后的列表,然后再 v-for 遍历。

  2. 为了避免列表渲染和完全隐藏通过执行导致预期不明确,可以将 v-if 移动至容器元素上

- 总结:

  在遍历的时候如果部分 DOM 条件渲染,则使用计算属性解决

  在遍历的时候如果全部 DOM 同时一个条件渲染,则把 v-if 写在外层容器上

## 06.生命周期

1.  三个概念:

- 挂载:在执行 `new Vue()` 的时候,Vue 会先解析模板,将模板编译成一个 render 函数,然后 render 函数调用会得到虚拟 DOM,并把虚拟 DOM 转为真实 DOM 挂载到一个真实的 DOM 容器上,这样 Vue 实例就会 DOM 容器产生的关联,这个过程称作为挂载

- 编译:将 Vue 模板语法转换成虚拟 DOM 的过程

- 渲染:将虚拟 DON 转换成真实 DOM 的过程

2.  生命周期-初始化阶段

- Vue 或者某个组件被实例化,则进入初始化阶段

- `init Events & lifecycle`:初始化 Vue 或者组件实例(将来简称实例)的内部事件处理系统和生命周期系统

- `【beforeCreate】`：数据初始化和数据劫持 创建之前,在这个阶段我们无法拿到数据,数据还没有开始初始化

- `init injections & reactivity`:初始化 data 数据注入及完成数据劫持(把数据转为响应式数据)，同时也会初始化 props，computed，methods 等选项

- `【created】`:数据初始化和数据劫持 创建之后,这个是最早可以操作数据的生命周期函数

3.  生命周期-编译阶段

- 判断 Vue 的配置项中是否存在 el 选项

- 如果有 el 选项则继续向下判断,如果没有 el 选项则等待使用$mount 提供 el 选项,否则一直等待

- 判断有没有 template 的选项

- 如果有 template,则把模板直接编译得到一个 render 函数,render 函数返回虚拟 DOM

- 如果没有 template,则把 el 这个容器的 outerHTML 作为模板进行编译

4.  生命周期-挂载阶段:

- `【beforeMount】`: 挂载之前。此时视图呈现仍然是未被解析的 Vue 模板结构,在这个位置也不能操作 DOM

- 挂载：把 Vue 实例挂载的 el 的容器上,(根据 render 函数返回的虚拟 DOM 创建真实 DOM 并替换指定的 el 容器)

- `【!!!mounted】`:挂载之后,页面中呈现的是渲染成的真实 DOM,我们一般在这个阶段进行初始化操作(初始化请求数据,初始化订阅,绑定自定义事件,开启定时器等等)

5.  生命周期-更新阶段

- 当响应式数据改变的时候,进入更新流程

- `【beforeUpdate】`: 数据改变后,视图更新前

- 更新:得到新的虚拟 DOM 并使用 patch 函数进行 diff 算法比较后更新真实 DOM

- `【updated】`: 数据改变后,视图也更新后

6.  生命周期-销毁阶段

- 当 Vue 实例调用$destroy 方法的时候 或者 组件被条件渲染或者路由切换的时候被销毁时 则进入销毁阶段

- `【!!!!beforeDestroy】`: 实例销毁之前,主要是为了完成一些收尾的工作,比如清除定时器,取消订阅等等

- `teardown watchers`:实例销毁的时候,取消所有的 watcher 订阅

- `teardown child components`: 实例被销毁的时候,取消所有的子组件的实例

- `teardown eventlisteners`: 实例被销毁的时候,取消所有的事件监听器

- `【destoryed】`: 实例销毁之后,一般不使用这个钩子函数

7.  父子组件的生命周期流程

- 初始化阶段

  - 父组件的 beforeCreate---父组件的 created---父组件的 beforeMount---子组件的 beforeCreate---子组件的 created---子组件的 beforeMount---子组件的 Mounted---父组件的 mounted

- 更新流程

  - 父组件更新的数据子组件没有使用,则只有父组件重新渲染,子组件不会重新渲染

  - 父组件更新的数据子组件也使用了,父组件的 beforeUpdate---子组件的 beforeUpdate---子组件的 updated---父组件的 updated

- 销毁流程

  - 父组件的 beforeDestroy---子组件的 beforeDestroy---子组件的 destroyed---父组件的 destoryed

## 07.Diff 算法

1.  Vue diff 算法分析:

- 什么是 diff 算法?????diff 算法就是比较新旧虚拟 DOM 树,寻找差异的算法,在源码中是通过 patch 函数来完成的,所以我们也称作为 patch 算法

- diff 算法比较思路:深度优先,同级比较

- 执行过程

  - 当组件内部的响应式数据发生更新的时候,就会执行 vue 内部的 updateComponent 函数,在函数内部先执行\_render 方法生成新的虚拟 DOM,把虚拟 DOM 传递给\_update 方法,并调用\_update 方法

  - 在\_update 函数中,首先定义一个变量保存旧的虚拟 DOM(在 vm.\_vnode 属性上),然后再把\_update 接受的新的虚拟 DOM vNode 放在 vm 的\_vnode 属性上,此时在\_update 函数中就有了新旧虚拟 DOM,最后使用 patch 方法对新旧虚拟 DOM 进行比较

- patch 的比较过程

  - patch 函数首先使用 sameVnode 方法专门比较两个节点是否相同(相同:两个虚拟 DOM 节点的标签类型相同`[input还要比较type类型]`,并且 key 的值也要相同,如果没有写 key,则 key 的值是 undefined)

  - 如果 sameVnode 比较两个节点相同,则直接进入更新流程(1.把旧节点的真实 DOM 拿到新节点位置复用 2.对比新旧节点的属性是否相同,如果不同则更新 3.开始比较子节点)

  - 如果 sameVnode 比较两个不相同,则直接遍历新的节点创建新的元素,并直接删除旧的元素

- 比较子节点(比较子节点是否相等也是使用的 sameVnode)

  - vue 使用四个指针分别指向 新旧子节点列表 的 首尾节点

  - 首先比较新旧树的头指针,判断是否相同,如果相同则进入更新流程.....

  - 继续比较两个树的头指针,如果不相同,则比较新旧树的尾指针,如果相同则进入更新流程....

  - 如果头指针比较和尾指针比较都不相同,则比较头尾指针是否相同,如果相同则进入更新流程...

  - 如果上边的规则都不相等,则会以新树的头指针为基础,循环旧的虚拟 DOM 节点,如果存在相等则直接拿过进入更新流程,如果找不到则直接拿当前的新的虚拟 DOM 节点创建真实 DOM

  - 当新树的头指针超过尾指针的时候,比较结束,如果旧树中存在剩余节点,则删除这个剩余节点

2.  key 的作用:

- 在新旧虚拟 DOM 对比更新的时候,默认的 diff 算法是"就地复用"原则

- "就地复用":多个子节点比较的时候,如果没有添加 key 属性,则 key 属性都是 undefined,所以每一个新旧 DOM 的 key 都是相同的,所以就会简单的按照节点的顺序依次比较(如果新旧节点的顺序发生变化,vue 仍然都是创建新节点删除旧节点)

- 我们可以给每一个节点添加一个 key 属性,方便 Vue 跟踪每一个元素的身份,从而在 diff 算法计算的时候可以按照 key 确定比较节点

- key 的作用:高效的更新渲染虚拟 DOM

- 不要使用遍历出来的 index 作为 key(index 不是稳定性),key 的要求是 唯一性!!! 稳定性!!!

3.  简洁版 diff 算法流程：

- 当组件创建和更新的时候，vue 会执行内部的 update 函数，该函数使用 render 函数生成的虚拟 DOM 树,将新旧 DOM 树调用 patch 方法进行比较找到差异,并更新真实 DOM

- 对比的过程被称作 diff,vue 内部使用 patch 函数完成对比过程

- 在对比的时候,vue 采用深度优先,同级比较的方式

- 在比较的时候,通过虚拟 DOM 的 key 和 tag 来判断是否相同的

- 第一:先对根节点的新旧虚拟 DOM 进行对比,如果相同则将旧节点复用,然后更新数据,递归比较子节点,如果不同则直接根据新的虚拟 DOM 递归创建新的节点,并且删除旧的 DOM

- 第二:比较子节点,首先 vue 给新旧虚拟 DOM 都使用了两个指针,分别指向头尾,然后不断向中间靠拢进行对比(头头,尾尾,头尾,尾头,乱序),提高对比性能,在比较的过程中如果发现相同则进入更新流程,否则新增和移除 dom

- 按照上边的两点一直递归,直到整个 DOM 对比完成

## 08.组件

1.  组件的定义和使用

- 定义组件

  1. 定义组件使用 Vue.extend({})方法

  2. extend 方法接受一个配置对象作为参数,配置对象类似于 new Vue 时传递的配置对象(没有 el)

  3. 每个组件都有自己的生命周期,数据,方法,计算属性,watch 等等

  4. 定义组件的时候,要添加一个 name 配置,代表当前组件的名称

  5. 定义好的组件其实就是一个 VueComponent 构造函数

- 组件的注册

  - 如果想要在一个组件或实例中使用另外一个组件,则需要注册

  - 使用 components 配置项进行注册组件

- 组件的使用

  - 在模板中 使用 标签的方式 使用已经注册过的组件

  - 当组件被注册完并且被使用的时候,则会实例化 VueComponent 构造函数,得到对应的组件实例

2.  一个重要的内置关系:

- 问?想要给每一个组件实例扩展一个 count 属性,则给 VueComponent.prototype.count 设置是否所有的组件就有 count 属性了?

- 答:不是,因为每一个组件都有自己的 VueComponent 构造函数,并不是只有同一个 VueComponent 构造函数

- 组件实例的原型链:组件实例\==>当前组件的 VueComponent 构造函数的原型对象\==>Vue 构造函数的原型对象\==>Object 构造函数的原型对象==>null

- 从上边原型链所看,VueComponent 构造函数是继承了 Vue 构造函数 (VueComponent.prototype.**proto**===Vue.prototype)

- 得到结论:想要让所有的组件都能访问到一个属性,则我们需要把属性放在 Vue.prototype 上才可以

## 09.脚手架

1. 脚手架的安装

- `npm i -g @vue/cli`:安装全局的 vue 命令

- `vue create xxxx`:安装项目

- 选项

  1. `Manually select features

  2. `默认选择 Lint 和 bable` 回车确认

  3. `2.x`

  4. `ESLint with error prevention only`默认回车 eslint 错误时提示

  5. ` Lint on save`: 回车确认

  6. `In dedicated config files`:回车确认

2. 脚手架根目录文件

- `public`:公共文件,不需要被打包,直接复制到打包目录,`index.html`也会放在这个目录中

- `src`:开发者的工作目录

- `babel.config.js`:babel 的配置文件

- `.browserslistrc`:browserslist 的配置文件,用于给 bable 提示兼容的浏览器列表

  - `> 1%`:用户量大于百分之 1

  - `last 2 versions`:兼容最低两个版本

  - `not dead`:出来已经不再维护的浏览器

- `.eslintrc.js`:eslint 的配置文件

- `jsconfig.json`:是 Vue 脚手架中来配置 JS 语法支持的文件,告诉编译器哪些文件需要被编译,以及如何编译。还可以实现与编辑器的集成改善快速导航和代码提示等体验

- `.gitignore`:git 忽略文件

- `package.json`:包管理文件

- `vue.config.js`:脚手架的配置文件夹

3. 运行时环境的 vue 版本分析

- 如果不使用 render 函数,则会有如下报错:

  - `You are using the runtime-only build of Vue where the template compiler is not available`:你正在使用一个运行时环境的 vue 包,这个 vue 包的模板编译是不能使用的

  - `Either pre-compile the templates into render functions, or use the compiler-included build`.:要么你可以使用 render 函数来处理模板预编译,要么你可以使用编译器构建

- 为什么使用运行时(vue.runtime.js)的 vue 包

  - 在脚手架中,vue 把完整的 vue 包分为了两个包:vue 运行时版本的包+模板编译包

  - 因为脚手架中的项目是先打包后运行,而模板编译是在打包的时候就已经把模板编译为一个渲染函数(只要调用这个函数,就会得到虚拟 DOM)了

  - 所以在项目运行的时候(打包好的项目中),是不需要模板编译这个选项了,而是只需要 vue 的其他功能

  - 这样做的好处

    1. 可以提高组件的性能，避免每次渲染都要重新解析模板生成渲染函数的开销。

    2. 并且在打包好的项目中使用的 vue 不需要使用完整版本的 vue,只需要使用 runtime 版本的 vue 即可,可以节省 30%左右的大小

4. 脚手架中的 render 配置项及 h 函数?

- template 配置项只能在项目运行的时候,才能对它内部的模板进行编译,但是脚手架中使用的是运行时版本的 vue+模板编译的包,模板编译的包只是在打包的时候起作用,打包好以后的目录只有 运行时版本的 vue 无法编译 template 模板

- render 配置项是一个函数,当代码运行的时候,render 函数就会执行,render 函数接受一个 createElement 方法作为参数,createElement 方法是原生 js 的方式根据参数创建虚拟 DOM

- createElement 接受两种参数

  - 标签名,属性,子节点 组成的参数

  - 一个组件配置对象

- vue 中通常把 createElement 方法称作为 h 方法

5. vue 单文件组件的 template 标签解析方式

- 在 Vue 项目 打包过程中，针对每个单文件组件，Vue 会将 `<template>` 标签中的模板代码编译成渲染函数。这样，在组件实例化时，就可以直接使用已经预编译的渲染函数来渲染组件，而不用先进行模板编译的过程。

- 这一过程发生在 `webpack` 打包时通过 使用`vue-template-compiler`自动对每个单文件组件的`<template>`模板编译得到渲染函数。这样做的好处

  - 可以提高组件的性能，避免每次渲染都要重新解析模板生成渲染函数的开销。

  - 并且在打包好的项目中使用的 vue 不需要使用完整版本的 vue,只需要使用 runtime 版本的 vue 即可,可以节省 30%左右的大小

- 因此，Vue 单文件组件中的 <template> 标签可以说是最终转化成了 js 代码，并且被编译成预编译的渲染函数保存起来，以提高组件的运行效率。

6. eslint 在非脚手架环境下使用

- `npm init`:初始化包管理文件

- `npm i eslint`:下载 eslint 包

- `npx eslint --init`:初始化 eslint 配置文件(一步一步生成)

  - To check syntax and find problems

  - None of these

  - None of these

  - Does your project use TypeScript? » No

  - Browser

  - What format do you want your config file to be in? · JavaScript

- 如果不想一步步生成,则不需要第三步的操作,直接复制一个写好的 eslint 配置文件(`.eslintrc.js`)即可

  ```js
  module.exports = {
    //环境变量的配置
    env: {
      //当前是在浏览器环境下
      browser: true,
      //js语法环境支持到es2021
      es2021: true
    },
    //指定继承一些已经存在的规则,
    //eslint:recommended指的是eslint所有的规则中前边打对号的都要
    extends: "eslint:recommended",
    //编译配置兼容最新的es版本
    parserOptions: {
      ecmaVersion: "latest"
    },
    //我们配置的额外的规则
    /* 
        "off" or 0 - 关闭规则
        "warn" or 1 - 将规则视为一个警告（不会影响退出码）
        "error" or 2 - 将规则视为一个错误 (退出码为1)
        */
    rules: {
      "no-console": 2
    }
  }
  ```

- 检测 `npx eslint xxx文件路径`

- 检测和修复: `npx eslint xxx文件路径 --fix`

7. eslint 在脚手架中的配置和使用(希望在我们打包项目的时候,eslint 先介入检测)

- `npm init`初始化包管理文件

- `npm i eslint@7 -D`:下载 eslint 包

- `npm i eslint-loader@4 -D`:下载 eslint 包

- `npx eslint --init`:初始化 eslint 配置文件

- 我们把我们书写的代码放在 src 目录中,配置 webpack 打包 src 目录,在打包的时候 eslint 检测

- 配置`webpack.config.js`文件

  ```js
  const path = require("path")
  module.exports = {
    entry: "./src/main.js",
    output: {
      path: path.resolve(__dirname, "build"),
      filename: "dist.js"
    },
    mode: "development",
    module: {
      rules: [
        {
          test: /\.js$/,
          exclude: /node_modules/,
          loader: "eslint-loader"
        }
      ]
    }
  }
  ```

- 运行`webpack`打包目录,发现有 eslint 检测

8. 忽略 eslint 检查

- 直接在`eslint配置文件`中的 rules 中 关闭某个规则

- 在代码中禁用规则的方式 2:禁用某一行代码规则校验

  - 在当前行使用 `eslint-disable-line  xxxx?,xxx?`注释(行注释和块注释都可以),禁用当前行所有规或者 xxx 规则的校验

  - 在被禁用规则的代码行上方书写 `eslint-disable-next-line xxx?,xxx?`注释(行注释和块注释都可以),禁用注释行后边一行的代码校验

- 在代码中禁用规则的方式 3:禁用某一段代码的规则

  - 在代码段的开始书写 `eslint-disable xxx?,xxx?`块注释,对后边代码块进行禁用全部或者部分规则校验

  - 在代码段的结束书写 `eslint-enable xxx?,xxx?`块注释,对前边的规则禁用 表示结束

9. style 标签的 scoped 属性

- 我们在组件的 style 标签中书写的样式在打包后,其实是可以通用的,也就是不只是能控制自己组件的元素样式(这样并不一定合理)

- 我们可以给 style 标签添加一个 scoped 属性,则这个 style 标签中的样式就只有对当前组件内的元素生效了

- scoped 原理??????

  - 首先给当前 scoped 所在的组件所有的结构添加一个自定义属性(如果是组件,则给组件的最外层元素添加)

  - 给当前 scoped 所在的 style 中选择器添加一个属性选择器,属性是当前组件结构中添加的自定义属性

  - 所以 scoped 所在的 style 中的选择 器只能选择自己组件的元素或者子组件的最外层元素进行控制

10. 在 style 中如果开启 less 的使用

- 给 style 标签配置 lang 属性 值为 less

- 需要安装 less 和 less-loader 两个包

11. 样式穿透-深度选择器原理

- 什么叫样式穿透?正常来说,scoped 属性要给当前组件所有的选择器添加当前组件自定义属性选择器,那我们无法控制后代组件内的样式(因为后代组件内的自定义属性和当前组件肯定不一致),我们希望通过一种办法能够控制后代组件的样式,这种方法被称作为样式穿透

- 样式穿透原理:如果我们在两个选择器之间书写了深度选择器(`>>>` 或者 `/deep/`) 则深度选择器会转为后代选择器,并且深度选择器后所有的选择器将不再添加属性选择器

## 10.vue 组件化开发相关知识点

1. ref 属性

- ref 被用来给元素或子组件注册引用信息

- 我们就能通过当前组件实例上的$refs 属性拿到所有的 ref 引用信息

- 如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素

- 如果用在子组件上，引用就指向组件实例,我们可以操作子组件的数据等..算是父子组件通信的一种方式

2. props 的使用

- 作用:主要是为了做父子之间的通信

- 基础使用:

  - 给子组件标签上 通过属性的方式 传递一些值

  - 在子组件内部需要通过 props 配置项 接受父组件传递过来的值

  - 我们在子组件中就可以通过实例访问到 props 的数据

- props 是只读的

  - vue 和 react 一样都是单向数据流(数据的流动方向只能以单向的)

  - 在 vue 中不要尝试修改自己接受的 props 属性(无论是基本类型还是对象类型),这样是不符合规范的

- props 除了做父传子以外,还可以做子传父

  - 组件自己的数据只能自己内部修改,所以不能在其他组件修改当前组件的数据

  - 可以在当前组件内部书写一个函数,函数的作用是修改当前组件的数据

  - 把函数通过 props 的方式传递给子组件,子组件可以调用函数并传参,达到向父组件传递数据的作用

- props 的三种接收方式

  - props 的写法 1:直接数组的方式接收

  - props 的写法 2:对象形式,可以限制 props 值的类型

  - props 的写法 3:对象形式,可以限制 props 值的类型 必填等各种限制

- props 的批量传递

  - 如果我们想要把一个对象展开一个个传递给子组件内部,则我们可以使用批量传递

  - 直接使用`v-bind='需要批量传递的对象'`即可批量传递

  - 在子组件内部需要一个个接受 props

3. 单向数据流

- 在 vue 中,单向数据流是指数据从父组件传递给子组件,子组件只能接受父组件传递过来的数据,但是不能直接修改父组件的数据。这种传递数据的方式保证了数据流动方向的一致性，降低代码的复杂性，提高可维护性

- 在 vue 中通过 props 属性把数据从父组件传递给子组件,子组件只能接收从父组件传递来的数据，在 vue 中这些数据都是只读的！！！

4. 过滤器:

- 过滤器是什么:对要显示的数据进行特定格式化后再显示(适用于一些简单逻辑的处理)

- 过滤器分类

  - 局部过滤器

  - 全局过滤器

- 过滤器书写方式

  - 在配置项中使用`filters`配置项添加过滤器函数,或者在全局使用`Vue.filter`方法注册全局过滤器

  - 过滤器函数的第一个参数是被过滤的数据

  - 过滤器函数的第二个参数是过滤器调用是可选的传参

  - 过滤器函数 return 的值就是最终过滤出来的值

  - 在插值语法中 使用 `数据 | 过滤器` 的语法使用某个过滤器

  - 在插值语法中 使用`数据|过滤器|过滤器|...`的语法直接使用多个过滤器

5. 自定义指令

- 指令:需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令,所以自定义指令主要用来操作 DOM

- 自定义指令的定义

  - 全局自定义指令

  - 局部自定义指令

- 自定义指令的定义过程

  - 通过配置项的 directives 属性配置自定义指令函数

  - 或者使用`Vue.directive()`方法配置全局自定义指令

- 自定义指令的钩子函数

  - `bind`:初始化指令的时候执行

  - `inserted`:被绑定元素插入父节点时调用

  - `update`:所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前

  - `componentUpdate`:指令所在组件的 VNode 及其子 VNode 全部更新后调用

  - `unbind`:只调用一次，指令与元素解绑时调用

- 自定义指令的钩子函数的参数

  - 第一个参数是当前指令所在的 DOM 元素

  - 第二个参数是当前指令的详细 binding(里边有一个 value 属性就是指令的值)

- 自定义指令的简写

  - 自定义指令的第二个参数不书写配置对象,而是直接写为一个函数,则这个函数默认是钩子函数中的 bind 函数

- 自定义指令的使用

  - 自定义指令在模板中使用 `v-自定义指令名称`使用即可

6. Vue 的插件及使用

- 当全局扩展一些内容的话,我们可以把逻辑封装起来,使用插件引入项目

- 常见使用插件的内容:1.全局过滤器 2. 全局自定义指令 3. 全局组件 4. Vue 的原型对象上的方法或属性

- 封装插件的时候我们可以暴露一个对象(对象内部必须拥有 install 方法),或者暴露一个函数,install 方法或者这个函数默认接受 Vue 作为参数

- 我们在入口文件中引入这个插件,并且使用 Vue.use()使用插件,如果插件是对象,则默认调用对象的 install 方法,如果插件是函数,则默认当做是 install 方法调用,都会传递进入一个 Vue 作为参数

## 11.Vue 组件通信

1. props

- 作用:做父子组件通信

- 父传子:给子组件标签通过属性的方式传递数据,子组件通过 props 属性接收

- 子传父:给子组件标签通过属性的方式传递一个函数,子组件接收函数之后,调用并传参,因为函数在父组件中定义,所以父组件就可以接收到子组件传递的数据

- 总结:如果 props 传递的是数据则代表父传子,如果 props 传递的是函数则代表要子传父

2. 自定义事件

- 什么是自定义事件

  - 给子组件绑定一个自定义事件

  - 在子组件内部触发自定义事件,父组件的事件函数就可以调用,达到传值的目的

- 给组件绑定事件

  - 只要给组件绑定事件,则都认为是自定义事件(必须我们自己触发)

  - 如果想要给组件绑定原生事件,则需要使用 `.native` 修饰符

- 给组件绑定事件的方式

  1. 直接通过 v-on 指令给子组件绑定自定义事件,事件函数定义父组件中(事件函数的形参就是子组件触发事件时传递的值)

  2. 可以通过 ref 获取到组件实例,然后调用组件实例的$on方法绑定事件($on 方法的第一个参数是事件名称,第二个参数是事件函数)

- 触发当前组件的自定义事件方式

  1. 在组件实例上有一个$emit方法,可以触发当前组件的自定义事件($emit 方法的第一个参数是事件名称,后边的参数都是向父组件传递的数据)

- 解绑自定义事件

  - 我们可以调用子组件实例上的$off 方法对子组件的自定义事件进行解绑

  - $off 方法可以接受 3 种参数(1.字符串,代表解绑某个事件;2.数组,代表解绑一个或多个事件;3.没有参数,代表解绑所有事件)

3. 事件总线$bus

- 什么是事件总线

  - 事件总线主要是使用自定义事件来完成组件通信的，但是主要做的任意组件通信

- 事件总线思路

  - 我们找一个可以被绑定自定义事件的东西（vm），放在所有组件都能访问到的地方（Vue.prototype）,起一个名字叫做$bus

  - 在接收数据的地方的初始化中(mounted)中,给$bus 绑定自定义事件,事件函数在当前组件内部

  - 在发送数据的地方给$bus 调用自定义事件并传值,则绑定事件的组件就会收到事件调用,并调用函数,最后完成了接收值

- $bus 的绑定

  - 我们在 new Vue 的配置中书写一个 beforeCreate 生命周期函数中书写`Vue.prototype.$bus=this`

  - 因为内部的组件会在 mounted 中的绑定事件,所以我们必须在他的 mounted 之前把$bus 绑定上去,所以要在(beforeCreate,created,beforeMount 中任选一个绑定即可)

4. PubSub-发布与订阅

- PubSub 是我们使用第三方包进行任意组件通信的

- 思想是 pubsub 提供了一个对象作为中介，数据的传输方可以给这个中介发布某些固定名称的数据，数据的接收方可以在这个中介订阅某些固定名称的数据,一旦发布新的数据,则订阅方就会收到 pubsub 的通知,接收数据执行函数

- 发布:PubSub.publish("name",data)

- 订阅:PubSub.subscribe("name",fn),fn 的第二个参数是接收的新数据

- 取消消息的订阅: PubSub.unsubscribe("name")

5. v-model 做父子组件的双向绑定

- v-model 用在表单元素上,可以实现收集当前表单的数据

- v-model 用在组件上,经过组件内部的配合,可以实现父子组件的双向绑定

- v-model 的本质是 :value="" + @input 事件

- v-model 实现父子组件双向绑定的原理

  - 当 v-model 绑定给组件的时候,其实就是给组件设置了一个叫做 value 的 props,和一个 input 的自定义事件

  - 组件内部 可以获取叫做 value 的 props,并且当数据一旦被修改就调用 input 这个自定义事件

  - 以上完成就可以实现父子组件使用 v-model 通信

6. v-bind 指令.sync 修饰符做父子组件的双向绑定

- .sync 修饰符的本质：先强制绑定一个`props`属性，然后再给组件绑定一个`@update:props`名 的一个自定义事件，自定义事件内部是把接收的数据修改了 props 的值

- 在组件内部可以首先接受`props`的值,然后再调用`@update:props`名的自定义事件 向外部传递值

- v-model 和.sync 修饰符的区别

  - v-model 只能在组件上绑定一次,而.sync 修饰符可以绑定多次

  - v-model 的本质和.sync 的本质也不一样

  - 一般来说给组件内部的表单双向绑定可以使用 v-model,如果给其他绑定则使用.sync,当然如果要绑定多个,只能选择.sync

7. $attrs&&$listeners 通信

- 主要是用来方便的书写深度的通信(祖孙)

- $attrs 可以接受来自父组件传递过来的 props,除了已经被当前组件接受的 props 和动态样式,然后我们可以通过 v-bind 批量传递给深层次的组件

- $listeners 可以接受来自父组件传递过了的所有的自定义事件,我们可以通过 v-on 给深层次的组件继续批量绑定自定义事件

8. $children&&$parent

- $children 获取一个包含所有子组件实例对象的一个数组,既然能拿到所有子组件的实例,则可以操作这个子组件身上的数据等等,但是很少使用,因为无法方便确认子组件的身份

- $parent 获取当前组件的父组件实例对象,但是因为一个组件可以被使用多次,所以我们无法确认父组件的身份,使用较少

9. $refs

- 如果 ref 设置给一个普通元素上,则代表获取当前 DOM 元素

- 如果 ref 设置给一个组件,则获取的是当前组件的组件实例,我们就可以操作这个组件的数据

10. $root

- 每一个组件的组件实例上都有一个$root 属性,指向当前组件树根 Vue 实例 vm

- 我们就可以借助这个$root做一个最牛逼的状态提升,并且不需要把数据一层层传递下去,后代组件直接使用$root 就可以访问到

11. slot 插槽

- 主要是为了实现父组件向子组件传递模板结构

- 插槽分为默认插槽(匿名插槽),具名插槽,作用域插槽

- 默认插槽:我们传递的插槽结构不需要控制名称,会直接把结构替换组件内部对应的`<slot>`占位标签

- 具名插槽:在组件内部的`<slot>`占位标签上需要使用 `name属性`设置一个名字,我们传递插槽结构的时候,需要在结构的外层添加一个`template标签`,在`template标签`上书写`v-slot:name(简写为#name)`来传递对应名称的插槽结构

- 作用域插槽:当组件内部接受到的值需要再次传递给外部的时候,需要在`<slot>`占位标签上使用 props 的方式向外传递数据,在传递插槽结构的时候需要在外层的`<template>`标签上使用`v-slot:name="obj"`接受住所有内部传递出来作用域插槽数据

12. provide/inject 提供/注入

- 主要是用做祖孙之间的通信(提供数据的是祖,接受数组的是孙)

- 父组件中可以书写一个 provide 的配置项,用来提供数据,provide 建议书写成函数格式,内部 return 对象

- 子组件中可以书写一个 inject 配置项,用来接收数据,inject 的格式是数组

- provide/inject 默认通信的数据是没有响应式的,解决方式

  - 传递的参数是一个方法,子组件中调用这个方法接受值(推荐)

  - 将提供的数据放在对象内部,然后再提供对象

## 12.vuex

1. 创建基础的 vuex 仓库

- 安装 vuex@3 `npm i vuex@3`

- 新建一个仓库文件夹和仓库文件`src/stores/index.js`

- 初始化 store 仓库

  ```js
  //1. 引入vue和vuex
  import Vue from "vue"
  import Vuex from "vuex"

  //2. 使用vuex插件
  Vue.use(Vuex)

  //3.实例化一个vuex仓库,并暴露

  //4. 给仓库传入配置(state mutations actions getters modules)
  export default new Vuex.Store({
    state: {
      count: 0
    },
    mutations: {},
    actions: {},
    getters: {}
  })
  ```

- 在组件内使用(方式 1):直接在组件中引入暴露的 store 对象,即可使用 store 的数据和方法

- 在组件内使用(方式 2):在入口文件使用 Vue 的 store 配置项,把 store 对象可以直接以$store 属性名的方式注入到每一个组件实例上

2. 读取 vuex 中 state 的方法

- 方式 1:在模板中直接使用$store.state.xxxx 的方式读取值

- 方式 2:可以使用计算属性拿到值,在模板中直接使用计算属性

- 方式 3:使用 mapState 辅助函数

  - mapState 的使用,参数是一个数组或者对象,数组或对象内是我们要去 store 拿的值

  - mapState 返回一个对象,对象内部其实就是读取值的对应的计算属性的方法

  - 使用对象展开运算符,把 mapState 的返回值在计算属性 computed 中展开

3. 在 getters 中书写 vuex 的计算属性

- 有时候我们需要从 store 中的 state 中派生出一些状态,需要使用 vuex 的 getters

- vuex 的 getters 其实类似于 vue 组件的计算属性

- getters 内部的函数接受 state 作为参数,函数内部必须要返回一个值

- 组件中使用 getters 的值

  - 直接在插值中使用`$store.getters.xxxx`

  - 在 computed 中封装函数

  - 直接使用 mapGetters 辅助函数

4. mutations 修改 state 的值

- 首先在 store 的 mutations 配置对象中封装函数,mutations 中的函数是修改 state 数据的唯一途径,所有每一种修改 state 的操作都会在 mutations 中的方法内进行

- mutations 中的方法接受一个参数就是 state 对象,第二个参数是调用这个函数时传递的载荷(payload),我们建议传递载荷的时候使用对象

- 在组件内使用$store 上的 commit 方法来调用 mutations 中的函数,commit 方法接受两个参数,参数 1 是事件类型(mutations 中的函数名),参数 2 是调用函数时传递的载荷(payload),也就是参数

- 在组件内使用 commit 方法调用 mutations 的函数

  - 直接在插值中使用`$store.commit(type,payload) `

  - 在 methods 中封装函数,函数中写`$store.commit(type,payload) `

  - 直接使用 mapMutations 辅助函数(可以接受一个数组或者对象),其实就是帮我们得到一个包含调用 mutations 方法的一个对象 ,我们直接在 methods 中展开即可

5. 在 actions 中进行异步操作

- 在 mutations 也可以异步修改 state,但是开发者工具不会监听到数据的变化,导致工具和视图的数据不一致

- 我们可以把异步获取数据或者异步操作放在 actions 中,然后异步操作结束之后,在 actions 内部提交给 mutations 对应的函数进行修改数据

- actions 接受两个参数,一个是一个阉割版的 store 对象,内部有 commit 的方法可以提交 mutations,另一个参数就是组件中分发 actions 时传递的参数 payload

- 组件中调用 actions 的方法

  - 直接在插值中使用`$store.dispatch(actionsName,payload)`

  - 在 methods 中封装函数

  - 直接使用 mapActions 辅助函数(可以接受一个对象或者数据),其实就是帮我们获得一个包含分发 actions 方法的一个对象,我们直接在 methods 中展开即可

6. Vuex 的模块化

- 如果多个功能的数据都保存在 state 中,则不好维护,数据及操作繁杂

- 我们可以创建多个 vuex 的模块保存不同的数据

- 过程

  1. 一个 vuex 模块其实就是暴露一个对象的文件,对象内部有自己的 state mutations getters actions 属性

  2. 在 vuex 的 index 中引入模块,并在 new Vuex.store()的配置对象中使用 modules 属性配置模块即可

  3. 此时的模块只是模块化了 state 数据,并没有模块化 getters mutations actions 的东西

  4. 所以 getters mutations actions 正常使用,但是 state 需要`$store.state.模块名称.数据`获取

- 模块的优化

  - 我们在暴露 vuex 模块对象的时候,添加一个属性 namespaced:true(开启命名空间)

  - 并且在使用辅助函数的时候,直接把辅助函数的添加第一个参数是当前要获取值的模块名称即可

  - 如果不使用辅助函数,则在获取 state 数据的时候,要使用 store.state.模块名.数据

  - 如果不使用辅助函数,则在获取 getters mutations actions 的时候,只需要在他们的名字前添加模块名即可,比如'模块名/increment'

7. vuex 数据的持久化

- 面试常问:页面一旦刷新数据会丢失怎么办?---数据持久化

- 手动数据持久化

  - 定义一个初始的 state 的值,给 state 赋值的时候先去 localStorage 中读取值,如果没有则得到初始的 state 的值

  - 在所有的 mutations 方法中,在改变 state 语句后 重新保存 localStorage

- 自动数据持久化

  - `npm install vuex-persistedstate --save`

  - 在 store 下的 Vue.Store({})中使用插件 plugins 配置` plugins: [createPersistedState()]`

8. 使用常量来替代 mutations 的事件类型

- 可以在`mutation_types`的文件中定义所有模块的 mutations 事件类型,使用常量

- 在 mutations 中事件名引入定义常量(注意使用属性名表达式)

## 13.路由

1. Vue 的动态组件

- Vue 提供了一个`<component>`组件,可以用来做动态组件

- `<component>`是一个占位符,接受一个`is属性`,`is属性`的值是一个 字符串类型 的已经被引入和注册的组件的名称

- 我们可以通过改变 is 强制绑定的值,来切换替换`<component>`的组件

2. Vue 动态组件的 keep-alive

- `<keep-alive>` 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们

- `<keep-alive>` 默认缓存所有动态组件

- 属性:`include` 和 `exclude` prop 允许组件有条件地缓存

  - `include和exclued`写法 1 逗号分隔字符串:`<keep-alive include="Count,Movie"> `

  - `include和exclued`写法 2 数组:`<keep-alive :include="['Count']">`

- 属性：`max`:规定最大缓存个数

3. keep-alive 的生命周期函数

- activated:被 keep-alive 缓存的组件激活时调用。

- deactivated:被 keep-alive 缓存的组件失活时调用。

4. vue 的异步组件

- 我们如果直接使用 import 模块化引入 vue 组件，则 webpack 在打包构建的过程中，会把所有的 js 都打包到了一起，但是里边包含了很多我们暂时没有使用的模块，这样包的体积过大，就会造成进入首页的时候需要加载的内容过多，出现长时间的白屏现象

- 我们可以使用异步组件，让 webpack 打包的时候把组件进行分开打包，需要的时候再去加载这个组件

- 异步组件的设置

  1. Vue 允许你以一个函数的方式定义组件，函数内部使用 import 方法引入某个模块,并把结果返回

  2. wabpack 在打包的时候，遇到 import 动态引入，则会把 import 动态引入的资源进行单独打包

  3. Vue 只有在这个组件需要被渲染的时候才会触发该函数，且会把结果缓存起来供未来重渲染

  4. 函数内 import 方法返回 promise 实例，当 import 引入成功则 promise 变成成功状态,然后就可以渲染当前组件了

5. hash 模式原理

- hash 模式是一种把前端路由的路径用`#`拼接在真实 URL 后面的模式。

- 当用户切换路由的时候使用`location.hash`的方式切换 hash 值

- `#`后面的路径发生变化时，浏览器并不会重新发起请求，而是会触发`hashchange`事件。加载对应的组件

- hash 模式的浏览器兼容性较好，就是看起来不够优雅。

6. history 模式

- history 模式用到了 HTML5 中的 history API,允许开发者直接更新浏览器 URL 地址而不重新发起请求。

- 用到了 history API：replaceState、pushState、back、forward 和 go 这个 5 个方法。

- 使用 window 的`popState`事件可以监听历史记录的改动,并加载对一个组件

- history 兼容性不如 hash 模式，而且浏览器在刷新的时候会按照路径发送真实的资源请求，因此在线上部署基于 historyAPI 的单页面应用的时候，一定要后端配合支持才行

- 后端:如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面

7. 初始化路由引入

- 安装路由`npm i vue-router@3`

- 在`router/index.js`中引入 Vue 和 VueRouter

- 使用`VueRouter`插件

- 实例化一个 VueRouter 对象`new VueRouter({配置})`

- 把 VueRouter 暴露出去

- 在入口文件中引入 Router,然后在 Vue 的配置项中使用 router 选项把$route和$router 注入到每一个组件实例上

8. 创建一级路由

- 在 router 的配置项中配置 routes 配置项,值是一个数组,数组包含多个路由映射关系配置对象,其中`path`代表要去匹配的路由地址,`component`是展示的路由组件

- 路由组件一般会放在`pages`文件夹中,而`components`文件夹一般用来放公共组件

- 我们需要在展示路由组件的地方书写一个`<router-view>`组件占位,这个组件专门用来渲染路径匹配到的视图组件

9. 配置二级路由

- 在 routes 的某一个需要配置二级路由的某个一级路由的配置对象中 添加一个 children 属性,值是一个数组,数组中可以书写多个二级路由的对象配置

- 在一级路由展示的路由组件中 书写二级路由的占位组件`<router-view>`

- 注意二级路由的 path 要么书写完整路径比如`/home/news`,要么值书写当前 path 比如:`news`

10. 默认路由和默认子路由

- 在一级路由中,我们可以使用 redirect 属性进行重定向路由

- 在二级路由中,我们也可以使用 redirect 属性进行设置默认子路由(直接写在一级路由上设置默认子路由.或者写在二级路由配置中新增一个空的规则,然后重定向)

11. 任意路由

- 在所有的路由规则最后书写任意路由

- 任意路由是当之前的规则都无法匹配的时候,会进行匹配任意路由

- 一般任意路由会导航至 404 页面

12. 命名路由

- 有时候，通过一个名称来标识一个路由显得更方便一些，特别是在链接一个路由，或者是执行一些跳转的时候。

- 可以在创建 Router 实例的时候，在 routes 配置中给某个路由通过 name 属性设置名称。

13. 切换路由模式

- 在 router 的配置中使用 mode 配置项,设置为 history 即可切换为 history 模式

14. 编程式路由导航

- 我们还可以借助 router 的实例方法`$router.push()`来进行定义导航链接

  - 该方法的参数可以是一个字符串路径,比如`$router.push("/home/news")`

  - 或者一个描述地址的对象,对象内部有 name 和 path 属性可以控制导航到哪一个路由,path 和 name 随意使用一种即可,path 的值是完整的地址,name 的值是路由的命名

- 编程式路由导航的其他方法

  - `router.replace()`:和 router.push 一致,但是不会留下任何的历史记录

  - `router.back()`:历史记录回退 1

  - `router.forward()`历史记录前进 1

  - `router.go(n)`历史记录前进或回退 n

15. 编程式路由导航重复点击 bug

- 编程式路由导航重复点击的时候会出现报错,报错的原因是:如果重复导航 push 或者 replace 则会返回一个失败的 promise 实例,但是 push 原本没有做任何处理,所以浏览器会报错,表示有失败的 promise 没有被处理

- 解决方式

  - push 可以接受第二个和第三个参数,分别是导航成功和导航失败的回调函数,如果我们书写了第三个参数处理导航失败(函数内容随意),则解决错误

  - 如果 push 没有书写第二个和第三个参数,则 push 会返回一个失败的 promise,我们可以使用 catch(()=>{})来处理这个错误即可解决

  - 最终写法,我们可以重写`VueRouter.prototype.push`方法,内部让原始的 push 都添加上第三个回调函数即可

16. 声明式路由导航

- 声明式路由导航,使用 router-link 组件

- 其实 router-link 组件内部也是使用的 router.push 进行导航

- 其中`to`属性接受的参数就是 push 方法接受的 location 参数,用来控制跳转

- 其中`tag`属性有时候想要 <router-link> 渲染成某种标签， 我们使用 tag 指定何种标签，同样它还是会监听点击，触发导航(目前建议使用插槽解决)

- 其中`replace`:设置 replace 属性的话，当点击时，会调用 router.replace() 而不是 router.push()，于是导航后不会留下 history 记录。

- 其中`active-class`:设置链接激活时使用的 CSS 类名

17. 在路由中使用 keep-alive

- 所以路由的 router-view 组件外也可以嵌套 keep-alive 组件,并可以使用 keep-alive 的属性及生命周期

18. 路由组件懒加载

- 当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了

- 路由懒加载：路由组件的异步加载（路由组件被单独打包,并且被需要的时候才去加载这个文件）

- 结合 Vue 的异步组件 和 Webpack 的代码分割功能 ，轻松实现路由组件的懒加载

19. 动态路由

- 我们经常需要把某种模式匹配到的所有路由，全都映射到同个组件。例如，我们有一个 User 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染

- 因为组件一样,但是组件内部要区分对应路由是哪个,所以我们可以在 路由路径中使用“动态路径参数”来达到这个效果

- “动态路径参数”可以有 query 和 params 两种写法

20. 动态路由的---params 传参

- 可以在路由导航的时候在路由后添加 params 参数

- 必须要在路由配置的 path 中去书写接受 params 参数的属性名,格式是`/:xxx/:xxx?`

- 在组件中使用`$route.params`来接受 params 参数

- 注意事项:

  - 如果在导航的时候使用 location 对象形式和 params 配合使用,则不能使用 path 导航,必须使用 name

  - 可选的 params 参数不能是一个空串(要么书写一个 null)

21. 动态路由的---query 传参

- 可以在路由导航的时候传递查询字符串参数

  - 1. 直接在路由字符串上拼接查询字符串即可

  - 2. 可以在 to 为 location 对象写法时候添加 query 属性为一个对象,对象内部就是 query 参数

- 在路由组件中通过$route.query 来拿到接受的 query 传参

22. 路由组件 props 传参

- 除了动态路由可以向组件内部传递 params 和 query 参数以外,我们也可以在路由表中使用 props 属性给某个特定的路由传递参数

- props 是一个对象:在组件内部就能通过 props 属性接受到 props 对象中传递的数据

- props 是布尔值为 true:会把当前路由规则接受的 params 参数通过 props 的形式传递给组件内部

- props 是一个函数:当当前的路由规则被匹配的时候,props 函数就会执行,props 函数接受当前路由的$route作为参数,props函数的返回值对象中的属性 就是将来在组件内部能够通过props属性获取的值,我们就可以在props函数内部拿到$route 中的 params 属性和 query 属性,使用 props 的形式传递给组件内部

23. 路由的元信息

- 定义路由的时候可以配置 meta 字段

- meta 一般是一个对象,meta 的数据其实就是路由的元信息(描述当前路由的一个固定信息)

- 我们可以在组件内部通过 $route.meta 得到元信息的内容

- ????在 react 中, 通过遍历 routes 路由表,得到每一个组件的元信息

24. 监听动态路由的改变

- 动态路由是组件已经复用了,但是传递的动态参数可能会发生变化,我们需要监听动态路由的改变

- 方式 1:把 params 和 query 参数通过 props 的方式传递到组件内部,props 是响应式的

- 方式 2:因为每次动态路由切换,$route都会改变,所以可以使用watch监听$route 的改变得到值

- 方式 3:我们主要目的是监听$route并且得到一个值,所以可以使用计算属性的方式监听$route 的改变,并直接得到值

25. 路由导航守卫

- 全局导航守卫

  - 全局前置守卫:router.beforeEach(),所有导航都会最先触发(身份验证,页面访问限制,日志记录,页面跳转确认)

  - 全局解析守卫:router.beforeResolve():在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用(了解)

  - 全局后置钩子：router.afterEach()导航已经全部完成，没有 next 参数

- 路由独享守卫

  - 独享守卫：设置在路由表的规则对象中,beforeEnter(),针对某一个路由进行守卫

- 组件内守卫

  - 组件内进入时守卫:beforeRouteEnter()刚刚进入当前组件,但是在渲染当前组件前就调用(当前没有 this,可以在 next 中书写回调函数,回调函数的参数就是当前的组件实例)

  - 组件内更新时守卫:beforeRouteUpdate()在当前路由改变，但是该组件被复用时调用(一般指的是动态路由 params 和 query 参数切换)

  - 组件内离开时守卫:beforeRouteLeave()导航离开该组件的对应路由时调用

- 守卫钩子函数的参数

  - to: 即将要进入的目标 路由对象

  - from: 当前导航正要离开的路由

  - next: 一定要调用该方法,来确认守卫后导航下一步的行为(1.参数是空代表放行 2:参数是一个地址字符串,代表重新导航到该地址)

26. 完整的导航解析流程

- 导航被触发。

- 在被离开的的组件里调用 beforeRouteLeave(组件内离开时守卫) 守卫。

- 调用全局的 beforeEach(全局前置守卫) 守卫。

- `[可选]`如果当前组件是重用组件则调用 beforeRouteUpdate(组件内更新守卫) 守卫 。

- 如果当前组件是新进入组件,则在路由配置里调用 beforeEnter(路由独享守卫)。

- 解析异步路由组件(因为要进入组件了,要先把组件解析)。

- 在被激活的组件里调用 beforeRouteEnter(组件内进入时守卫)。

- 调用全局的 beforeResolve(全局解析守卫) 守卫 。

- 导航被确认。

- 调用全局的 afterEach(全局后置钩子) 钩子。

- 调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。

## 14.vue 其他

1. Mixin 混入

- 混入(Mixin)是一个对象,可以包含任何组件的配置项

- 当组件使用混入对象的时候,所有混入对象的配置项都会混入到当前组件中

- 在组件中可以使用 mixins 选项,值是一个数组,进行混入对象

- 合并冲突问题?

  - 数据合并冲突?组件内数据优先

  - 对象合并冲突?组件内数据优先

  - 生命周期冲突?两个都会执行

- 我们还能使用 Vue.Mixin()方法进行全局混入(慎用!!!!!)

2. 继承

- extends 选项可以让当前组件继承某一个组件的配置项(不能继承模板)

3. 函数式组件

- 函数式组件可以让组件没有状态和没有实例

- 函数式组件只能接受来自 props 的数据,并且在模板中只能使用 props.xxx 接受 props 数据

- 特点:

  - 没有状态

  - 没有 this

  - 没有生命周期

  - 没有 watch 监听计算属性等等等...

- 函数式组件的作用

  - 主要是为了展示组件(组件没有任何功能,而是为了展示结构的)

- 使用方法:

  - 在单文件组件中,直接给 template 标签设置一个 functional 的属性

  - 在非单文件组件中,设置 functional 配置项为 true 即可

4. $nextTick

## 15.vue 动画

1. Vue 的过渡动画配置

- 可以执行动画的前提是:

  1. 某个元素必须通过 v-show 或者 v-if 来控制

  2. 动画元素外层嵌套一个 transition 组件

- 动画由类名来控制

  - .v-enter,.v-leave-to:控制动画的元素在进入时,和离开之后的样式

  - .v-leave,.v-enter-to:控制动画的元素在进入后和离开时的样式

  - .v-enter-active,.v-leave-active 控制动画的元素在进入的过程中和移出的过程中的过渡动画效果

2. Vue 命名动画

- 正常来说当前页中所有的动画都受 v-xxx 控制,但是我们总是想动画有不同的效果

- 我们可以在 transition 组件中命名当前动画名称,添加 name 属性

- 在样式中以 我们的命名为开头书写动画 .name-xxx

3. Vue 的关键帧动画

- 我们可以在 Vue 的动画中直接使用关键帧

- 其实这个关键帧的 from 和 to 就是过渡动画中的 动画开始时的状态和动画结束后的状态

- 我们还要使用 v-leave-active 和 v-enter-active 进行关键帧动画的执行

4. Vue 动画使用第三方库

- 使用的是 animate.css 这个库 提供了非常多的关键帧名称

- 使用方式

  1. 安装包 npm i animate.css

  2. 在入口文件中引入 animate.css

  3. 在需要动画的 transition 组件上添加两个属性 enter-active-class 和 leave-active-class,属性的值就是 animate.css 中的关键帧名称 格式是 animate\_\_fadeInDown

  4. 给被执行动画的元素上添加一个 class:animate\_\_animated

5. vue 的路由使用动画

- 和之前学习的动画是一致的

- 使用 transition 组件包含住的是 router-view 组件

- 需要一点注意的是:切换的时候可能有两个组件同时显示,我们需要给隐藏的组件设置一个绝对定位不占用空间

## 16.数据响应式原理

1. 数据代理

- 我们给 Vue 实例或者组件实例设置的 data 数据,默认被放在了实例对象的`_data`属性中了,我们想要操作这个数据的时候都需要添加`_data`

- 为了更加方便的操作实例上的`_data`中的数据,我们可以把数据遍历在实例上放一份,但是其实操作实例上的数据,其实就是操作`_data`中对应的数据

- 过程

  1. 遍历`_data`的数据

  2. 使用`Object.defineProperty`的方法给实例扩展一个同名的属性名

  3. 属性值使用`getter`和`setter`存取器属性

  4. 当读取属性的时候,使用`getter`方法,返回`_data`的属性值

  5. 当设置属性值的时候,使用`setter`方法,设置`_data`的属性值

2. 数据劫持

- 目的:(收集)为了收集获取当前数据的模板的信息,(通知)为了通知收集的所有的模板进行更新数据

- 原理:`Object.defineProperty`

- 过程

  1. 遍历`_data`中的数据,得到属性和值

  2. 重写`_data`上的属性,并且书写为存取器数据

  3. 当取的时候直接返回当前属性的值,并收集当前的模板信息

  4. 当设置的时候修改当前属性的值,并通知所有的模板进行重新获取最新的值

3. 设计模式的观察者模式

- 当一个对象 A 中的数据被多个对象所依赖

- 并且当被依赖的对象发生改变的时候,会去通知所有的依赖项,我们就把这种模式称作为观察者模式

- 其中被依赖的对象我们称作目标对象,依赖项我们称作为观察者

4. 设计模式的订阅与发布者模式

- 订阅与发布者模式其实是属于观察者模式中的一个细分

- 观察者模式中的观察者被称作为 订阅者,观察者模式中的目标对象被称作为发布者

- 订阅者和发布者中间有一个统一的调度中心(订阅中心)来实现数据的通信, 并且订阅者和发布者都是不知道对方的存在的

- 当订阅者订阅数据的时候,来到订阅中心,订阅中心收集所有的订阅者

- 当发布者发布信息的时候,先传递给订阅中心,然后再由订阅中心统一传递给订阅者

5. Vue 数据响应式原理总结(响应式原理,数据双向绑定原理)

- 数据响应式原理的意思:当 data 中的数据被修改的时候对应视图会随之发生更新

- 主要由 3 个方面构成

  - 数据代理

  - 数据劫持

  - 发布与订阅者模式

- 详细过程

  1. 使用`Object.defineProperty`完成数据代理,把实例的`_data`上的数据遍历在实例身上代理一份,我们访问或者设置 vm 上的数据的时候,其实就是访问或者设置`vm._data`中的数据

  2. 有一个`Observer`类(就是发布订阅者模式中的发布者),主要是通过`Object.defineProperty`给 vm 的`_data`上的数据所有层级的属性都重写为`getter`和`setter`存取器属性,在`getter`中建立了`dep(订阅中心的实例化对象)`和`watcher(订阅者的实例化对象)`的关系(简单来说就是让对应的 dep 收集依赖),让`dep`收集访问当前数据的`watcher`,在`setter`中让 dep 通知所有的`watcher`进行重新获取数据(简单来说就是通知所有的当前数据的依赖更新)

  3. 有一个`Dep`类(发布订阅模式中的订阅中心,中间人),`Dep`上有收集所有`watcher`的方法,和通知所有`watcher`重新获取数据的方法,在数据的每一个属性在做劫持的时候,会创建一个`dep对象(Dep的实例化对象)`,在劫持的`getter`中调用`dep`的收集依赖的`depend`方法,在`setter`中调用`dep`的通知更新的`notify方法`

  4. 有一个`Watcher类(发布订阅模式中的订阅者)`,`Watcher`身上有获取数据的`get`方法和更新视图的`update`方法,每一个组件都对应一个`Wathcer`,`Watcher`会在第一次获取数据的时候被`dep`收集到数组中,当`dep`收到更新要求的时候,`dep`就会通知所有的`watcher`实例调用`update`方法重新获取数据并更新视图
