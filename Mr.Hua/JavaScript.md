# JS 笔记

## 03. js 的初步使用

1. script 标签的 async 和 defer 属性

- 没有设置任何属性

  - HTML 文件被解析，直到脚本文件开始下载为止，同时将停止解析 html
  - 下载并执行完成后将在恢复解析 HTML。

- defer 属性(延迟执行):

  - `<script>`标签有一个属性 defer，这个属性会让脚本立即下载,但是不会停止 html 的渲染。
  - 并且会让脚本下载完成后被延迟到整个页面都解析完成后再运行。
  - 如果页面中有多个延迟脚本，那么第一个延迟脚本会先于第二个延迟脚本执行
  - 适用于 script 标签外部外部引入 JS 文件，不适用于 script 标签包含的脚本
  - 常见于外部引入 js 的 script 标签,并且需要最后才执行的场景

- async 属性(异步加载):
  - `<script>`async 属性，让浏览器异步加载 JavaScript 文件，即表示应该立即下载脚本，但不应妨碍页面其它操作
  - 异步脚本下载完就会立即执行,不会等到 html 渲染结束,所以异步脚本不适合操作 DOM
  - 异步脚本不应该互相依赖,因为多个异步脚本同时下载的时候,谁先下载完谁就先执行
  - 适用于 script 标签外部外部引入 JS 文件，不适用于 script 标签包含的脚本
  - 常见于需要优先下载执行,并且没有操作 DOM,并且没有互相依赖的场景

5.  标识符的命名规范

- 什么是标识符:标识符:指的是变量、函数、属性的名字，或者函数的参数
- 规范:
  1. 区分大小写
  2. 开头只能是字母 下划线* 美元符号$三种之一,后边可以是字母 数字 下划线* 美元符号$
  3. 不能使用关键字或者保留字(top 也不能用!!!!!)
  4. 不能包含空格
  5. 多个单词组成的名称推荐使用小驼峰写法

6.  注释

- 单行注释
  - 只需要在被注释的代码前边添加 // 即可
  - 快捷键:`ctrl+/`
  - 一般是用来把某条代码注释掉，或者给某个代码书写一个文本注释
- 多行注释
  - 多行注释,需要在被注释的整个代码块的前边书写一个 `/*`,在被注释的后边写一个 `*/`
  - 快捷键是 ctrl+shift+/
  - 一般用来注释某一块完整的代码块，或者给某块代码添加注释

7.  语句分号结尾

- 一个分号代表一条语句的结束，所以我们要合理添加分号
- 一般来说只有`}`后边可以省略分号
- 如果一个分号，则代表这个是一个空语句

8.  作业:两个变量的值交换

- 方式 1:使用第三方变量
  ```js
  var a = 2
  var b = 5
  var c = a
  a = b
  b = c
  console.log(a, b) //5 2
  ```
- 方式 2:使用数学方式计算

  ```js
  var a = 2
  var b = 5
  
  a = b - a //a:3
  b = b - a //b:2
  a = a + b //a:5
  ```

## 03. 数据类型

1.  查看数据类型:

- typeof 就是负责提供数据类型信息的操作符，格式为 typeof a
- 有些时候 typeof 操作符会返回一些令人迷惑的值
  - 把 null 归为 Object 类型，而不是作为 Null 类型(在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息， 000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。)
  - 把函数归为 Function 类型，而不是 Object 类型

2.  数据类型的分类

- js 的数据类型分为 简单类型 和 复杂类型
- 简单类型:
  - null:空值
  - undefined:未定义
  - number:数字
  - string:字符串
  - boolean:布尔值
- 复杂类型
  - object:对象类型(数组,对象,函数......)

3.  函数知识点简单补充

- 函数是对一套逻辑的封装,当需要这个逻辑的时候,直接调用这个函数即可
- 可以给函数传递一些信息(参数)
- 函数可以返回一些值给我们
- 封装函数格式 `function 函数名(参数1,参数2...){函数体逻辑代码区域}`,函数只有被调用的时候才执行
- 调用函数格式 `函数名(参数1,参数2)`

4.  undefined 类型

- Undefined 类型只有一个值，即 undefined
- 我们几乎不会直接对一个值赋值 undefined,基本都是其他操作的一个错误反馈
- undefined 出现的场景
  1. 变量声明了但是没有赋值
  ```js
  var b
  console.log("b的值", b) //undefined
  ```
  2. 调用函数时，应该提供的参数没有提供，该参数等于 undefined
  ```js
  function increment(a, b) {
    console.log("a,b", a, b) //b是undefined
    return a + b
  }
  var result2 = increment(1)
  console.log("result2", result2)
  ```
  3. 函数没有返回值时，默认返回 undefined
  ```js
  function myself(name, age) {
    console.log("大家好")
    console.log("我是" + name)
    console.log("我的年龄是" + age)
  }
  var result3 = myself("张三", 18) //undefined
  console.log("result3", result3)
  ```
  4. 获取一个对象没有的属性的时候，该属性的值为 undefined
  ```js
  var laoWangGirlFri = {
    name: "lucy",
    age: 18,
    address: "武汉"
  }
  console.log("laoWangGirlFri.age", laoWangGirlFri.age)
  console.log("laoWangGirlFri.tel", laoWangGirlFri.tel)
  ```

5.  null 类型:

- null 类型是第二个只有一个值的数据类型，这个特殊的值是 null。
- typeof 因为遗留问题(看之前的解释)得到的结果是 object
- null 的主要含义代表空值
- null 类型的主要场景
  1. 如果定义的变量准备在将来用于保存数据，那么最好将该变量初始化为 null 而不是其他值
  ```js
  var a = null //目前需要先定义,但是未来才能被赋值
  a = 2
  ```
  2. 作为函数的参数，表示该函数的参数暂时没有传递
  ```js
  function add(name, age, sex) {}
  add("张三", null, 18)
  ```
  3. 把一个不使用的数据对象变为垃圾对象,需要把对象的变量名设置为 null(当一个对象没有变量名引用的时候,这个对象就是垃圾对象,就会等待浏览器的垃圾回收机制回收)
  ```js
  var person = {
    name: "小王",
    age: 18,
    sex: "男"
  }
  person = null //person之前保存的对象,不再被任何变量引用
  console.log("person", person)
  ```
  4. 原型链的终点是 null

6.  number 类型值的种类

- 整数
- 浮点数
- 二进制数 `0b开头 + xxxx`(浏览器打印会转为 10 进制)
- 八进制,旧的写法`0开头 + xxx`,新的写法`0o开头 + xxx`(浏览器打印会转为 10 进制)
- 十六进制:`0x开头 + xxx`(浏览器打印会转为 10 进制)
- 科学计数法:用 E 代表底数 10,后边跟 E 的指数,可以是正负值,比如`1.1e+11`,`1.1e-11`,`1.1E11`,`1.1E-11`
- Number.MIN_VALUE:浏览器在正数范围内展示最小数字 5e-324
- Number.MAX_VALUE:浏览器在正数范围内展示的最大数字 1.7976931348623157e+308
- Number.MAX_SAFE_INTEGER:浏览器表达的最大安全整数 2 的 53 次方
- Number.MIN_SAFE_INTEGER:浏览器表达的最小安全整数 -2 的 53 次方
- Infinity:当数字过大无法表达的时候,则表示无穷(无穷大(infinity)或者无穷小(-infinity)),只要大于 Number.MAX_VALUE(2 的 1024 次方)就会得到
- NaN(Not a Number):当一只值必须是数字类型,但是的确无法实现的时候,这个值就是 NaN,属于数字类型

7.  Infinity 补充:

- 代表无穷,Infinity 代表无穷大,-Infinity 代表无穷小
- Infinity 其他值的计算总结

  - Infinity 和任意值(NaN 除外)加法和乘法运算 都是 Infinity
  - Infinity 减去自身和除自身都是 NaN(无法计算)
  - Infinity 减去常规数字和除常规数字,则还是 Infinity
  - Infinity 乘以 0 得到的是 NaN
  - 任何数值 除 0 都是 Infinity(未来错误最常见)

- Infinity 的比较总结
  - Infinity 和 Infinity 的比较是相等的

8.  NaN 补充:

- 代表不是一个数字,但是是数字类型
- NaN 和其他值的计算只能得到 NaN
- NaN 和其他值的比较都是 false

9.  其他类型转 number 方式-Number()方法

- null 转 number : 0
- undefined 转 number : NaN
- string 转 number
  - 空的 string 转 number:0
  - 只有空格的 string 转 number : 0
  - 纯数字的 string 转 number : 直接转为对应的数字
  - 非纯数字的 string 转 number : NaN
- boolean 转 number
  - true 为 1
  - false 为 0
- 数组转 number
  - 空数组为 0
  - 只有一个值的数组,按照这个值的类型去转(特殊 boolean 转为 NaN)
  - 其他数组转为 NaN
- 对象转 number:NaN

10. 其他方式让其他类型转 number

- 一元运算符 `+`:直接在被转换的数据之前,添加+
- 让被转换的值 -0(减法运算会让数据转 number)
- 让被转换的值 \*1(乘法运算会让数据转 number)
- 让被转换的值 /1(除法运算会让数据转 number)
- 按位取反再取反,在被转换的值前添加 `~~`(~~转 number 的方式,不会出现 NaN 的情况,而是转为 0)

11. parseInt 的基础使用

- parseInt 主要是把字符串转为整数
- 如果 parseInt 的第一个参数不是字符串,则会直接转为字符串
- 按从左到右的顺序,逐个分析每个字符,直到发现非数字字符为止。
- parseInt()将把前面分析合法的数字字符全部转换为数值并返回。
- parseInt 可以把一个小数直接转为整数

12. parseInt 的进制转换功能

- parseInt 方法,可以把指定进制的数字的字符串格式,转为 10 进制展示
- parseInt 的第一个参数是 某一个进制数字的字符串
  - 注意:因为是字符串格式,是不需要添加对应进制的前缀的
  - 第二个参数是用来指定进行的
- parseInt 的第二个参数是 指定第一个参数的字符串是几进制
  - 第二个参数为 0，则默认代表 10 进制
  - 第二个参数为 1，则返回 NaN（因为没有 1 进制）
- parseInt 在转换过程中，如果违背了进制规则，也会返回 NaN

13. parseFloat():

    - 大概解析过程和 parseInt 相同。
    - 但是 parseFloat()它可以把值转换成浮点数，即它能够识别第一个出现的小数点，而第二个小数点视为非法。

14. 把十进制数转为其他进制

- 使用 number 的 toString 方法，接收一个参数，就是目标进制
- 转换的目标结果是一个字符串
- 如果 toString 没有接受参数,则默认转为对应字符串

15. String 类型:

- JavaScript 字符串(String)就是由零个或多个字符组成的字符序列。零个字符表示空字符串。
- 字符序列可以使用单引号(''),双引号("")(优先推荐使用),反引号(``)(ES6 新提出的,未来再学习)来表示
- 注意事项:
  1. 双引号字符串中如果需要写引号,则写单引号;单引号字符串中需要写引号,则写双引号
  2. 如果字符串中需要展示同类型的引号,需要使用(`\`)进行转义
  3. 如果字符串中需要在展示的时候换行,可以在字符串中添加换行符(`\n`)
  4. 书写的时候换行,在每一行的末尾书写一个(`\`)对回车换行符进行转义
- 字符串每一个字符都是有自己的下标的,下标从 0 开始依次递增,我们可以通过过 字符串[`n`]的方式获取某个下标对应的字符
- 字符串有一个 length 属性,获取获取字符串的长度

16. 字符串中转义字符的补充

- 转义字符是字符的一种间接表示方式。在特殊语境中,无法直接使用字符自身
- 一些字符加上反斜杠后会表示特殊字符,而不是原字符本身,这些特殊转义字符被称为转义序列
- 如果在一个正常字符前添加反斜杠,JavaScript 会忽略该反斜杠

17. 其他类型转 string 类型-String()方法

- number 转 string:直接转为对应的字符串,如果是其他进制的 number,则先转为十进制然后再转 string
- null 转 string:直接转为字符串'null'
- undefined 转 string:直接转为字符串"undefiend"
- boolean 转 string:直接添加上引号
- 数组转 string:去掉中括号,然后添加引号
- 对象转 string:直接变成'[Object object]'

18. 使用 toString 方法转 string 类型

- 除了 null 和 undefined 之外，其他的类型(数值、布尔、字符串、对象)都有 toString()方法，它返回相应值的字符串表现
- 转字符串规律和 String 方法一致
- 当有的时候 个别值会自动的转为字符串,默认调用的就是 toString 方法

19. Boolean 类型:

- 布尔类型仅包含两个固定的值：true 和 false。其中 true 代表真，false 代表假。

20. 其他类型转 boolean 规则:

- 转换方式 1:Boolean(),方式 2:!!
- 数字转 boolean:0 为 false 非 0 为 true
- 字符串转 boolean:空为 false,非空为 true
- null 转 boolean:false
- undefined 转 boolean:false
- 对象类型转 boolen:true

## 04. 运算符(操作符)

运算符是根据特定的规则对操作数执行运算 01. 逗号运算符:

- 在一条语句中,执行多个操作(常见一条语句中声明多个变量)
- 它能够先执行运算符左侧的操作数,然后再执行右侧的操作数
- 逗号运算符返回值:右侧操作数的值。

2.  乘性运算符:

- 乘性运算符分为 乘法 除法 求模（取余）
- 乘性运算符计算 会先把两个值转换成 number 类型 然后再计算
- 求模的时候,得到的正负取决于被除数(前边)
- 多个乘性运算符 从左到右 依次执行

3.  减法运算符:

- 减法运算符会先把操作数转为 number,然后再进行计算
- 多个减法运算符 从左到右 依次执行

4.  加法运算符:

- 加法操作符除了运算以外，还有字符串拼接的功能
- 加法运算中，如果出现一个是字符串 那么就把另一个转换成字符串 然后拼接
- 两个字符串相加，是将两个字符串链接再一起生成一个新的字符串
- 如果两个操作符中有一个是 object 类型(对象,数组等)..也会把两个操作数转为字符串按照字符串拼接
- 如果两个操作符中没有 object 类型和字符串类型,则会转为 number 然后执行加法

5.  赋值运算符:

- `=`是赋值的函数
- 赋值运算符左侧的操作数必须是变量、对象属性或数组元素。也称为左值
- 把等号右侧操作数的值直接赋值给左侧的操作数,因此左侧操作数的值会 发生变化。
- 一般先执行 赋值 右边的内容,然后再赋值给左边(赋值操作符的优先级仅仅大于逗号操作符)
- 赋值操作符 返回 等号右侧的值
- 多个赋值操作符是向左开始执行
- 赋值运算符除了`=`以外,还包含`+=`,`-=`,`*=`,`/=`,`%=`,`&&=`,`||=`,常用在对某个变量进行累加,累减...的计算
- 如果赋值运算符右侧是一个 object 类型,则把 object 的引用地址赋值给左侧的

6.  递增(++)递减(--)运算符:

- 递增(++)递减(--)都是一元运算符
- 递增(++)递减(--)作用:
  1. 对操作符的操作数进行加 1 或者减 1;
  2. 返回值
- 递增递减分为前置和后置,前置就是把(++,--)写在操作数的前边,后置就是把(++,--)写在操作数的后边
  1. 前置递增递减:一定会让操作数的值累加累减 1,并且返回值是累加之后的操作数的值
  2. 后置递增递减:一定会让操作数的值累加累减 1,并且返回值是累加之前的操作数的值
- 注意!!如果没有拿递增递减的返回值,则不管那种写法,最后结果都是让操作数加 1 或减 1 了(他们只有返回值的区别)

7.  关系运算符-大小比较:

- 关系运算也称比较运算,需要两个操作数,运算返回值总是布尔值
- 大小比较主要有 4 个
  - `<`:如果第一个操作数小于第二个操作数,则返回 true;否则返回 false
  - `<=`:如果第一个操作数小于或者等于第二个操作数,则返回 true;否则返回 false
  - `>=`:如果第一个操作数大于或等于第二个操作数,则返回 true;否则返回 false
  - `>`:如果第一个操作数大于第二个操作数,则返回 true;否则返回 false
- 不同类型值的进行比较的规律
  - 如果都是数字，则按照数字比较；如果都是字符串则按照字符串比较
  - 如果两个操作数有一个是除了和数字和字符串的其他类型,则全部转为数字比较
  - 如果有一个操作数是对象({}),则全部转为字符串比较
- 字符串比较规律:
  - 按照下标依次进行比较,比较两个字符的 ascII 码的大小
  - 如果第一个就比较出来大小,则直接返回结果
  - 如果第一个字符串都相等,则比较第二个字符,依次类推
  - 小写字母>大写字母>数字(http://c.biancheng.net/c/ascii/)

8.  关系运算符-相等全等比较

- 总共分为 4 种
  - `==`:比较两个操作数的值是否相等
  - `!=`:比较两个操作数的值是否不相等
  - `===`(推荐使用):比较两个操作数的值是否相等,同时检测它们的类型是否相同
  - `!==`(推荐使用):比较两个操作数的值是否不相等,同时检测它们的类型是否不相同
- 相等比较类型转化规律(了解)
  - 如果两个值类型相同,则没有类型转换,直接比较
  - 如果操作数是布尔值,则先转换为数值,其中 false 转为 0,true 转换为 1.
  - 如果一个操作数是字符串,另一个操作数是数字,则先尝试把字符串转换为数字
  - 如果一个操作数是字符串,另一个操作数是对象,则先尝试把对象转换为字符串。
  - 如果一个操作数是数字,另一个操作数是对象,则先尝试把对象转换为数字。
  - 如果两个操作数都是对象类型,则比较引用地址。 如果引用地址相同,则相等; 否则不等。
  - NaN 和任何值都不相等，包括自身
  - null 和 undefined 值相等，但是是不同的数据类型
  - null 和除了 undefined 和自身以外,都不相等
- 全等不全等比较:
  - 全等:先比较两个值的类型,如果类型不同,则直接返回 false,否则再比较两个值是否相等
  - 不全等:比较类型和值,只要类型和值有一个不同,就返回 true

9. 逻辑运算符:

- 逻辑运算符包含：逻辑与（&&）、逻辑或（||）、逻辑非（！）
- 逻辑与(&&):要求运算符前后的两个条件都是 true(如果不是布尔值,则会默认转为布尔值进行判断)
  1. 先执行&&前边的操作数,如果为 false,则直接停止与(&&)的操作,直接返回第一个操作数
  2. 如果&&前的操作数为 true,则执行&&后的操作数,无论后边的操作数是 true 还是 false,直接返回后边的操作数
- 逻辑或(||):要求运算符前后两个条件必须有一个是 true(如果不是布尔值,则会默认转为布尔值进行判断)
  1. 先执行||前边的操作数,如果为 true,则直接停止或(||)的操作,直接返回第一个操作数
  2. 如果||前的操作数是 false,则执行||后的操作数,无论||后的操作数是 true 还是 false,直接返回后边的操作数
- 逻辑非:先对!后的内容进行转换布尔值,然后返回对这个布尔值取反以后的值(一定返回布尔值)

10. 三元运算符:

- 语法格式：b ? x : y
- b 操作数必须是一个布尔型的表达式(如果不是则转为布尔值)，x 和 y 是任意语句
- 如果操作数 b 的返回值是 true,则执行 x,并且整个三元语句返回 x 的返回值
- 如果操作数 b 的返回值是 false,则执行 y,并且整个三元语句返回 y 的返回值

11. 一元运算符:

- 只有一个运算数的运算符，比如++ --：自增(自减)、+(-)：正负号等
- 一元加法运算对数字没有影响 但是对其他类型却转换成了数字
- 一元减法 对数字加一个负数 对其他类型先转换成数字 然后添加一个负号

## 05. 语句

1.  声明语句包含四种：

- 声明变量: var let const
- 声明函数: function
- 声明标签(label 声明):直接在循环前边书写一个名称
- 声明类:class

2.  调试语句：

- debugger 语句(调试语句，也称打断点)用于暂停 JS 执行
- debugger 语句可以放在代码的任何位置用以脚本中止执行
- 也可以在开发工具的 source 中，点击对应的代码行，添加断点

3.  if 语句-单分支:

- 书写格式：if (判断式){代码块}
- 如果判断式为真，则执行代码块。
- 判断式不一定要书写各种操作符，无论传递什么进去，if 都会把它(或者它的返回值)转换成布尔值 然后执行 if 代码
- if 判断语句的代码块中是单句，我们可以省略大括号

4.  if 语句双分支 else 语句

- else 语句仅在 if 或者 else/if 语句的条件表达式为假的时候执行。
- `if（判断式）{代码块1}else{代码块2}`
- 如果判断式为真，则执行代码块 1，否则将执行代码块 2

5.  if 语句-多分支(else if 语句)

- else if 语句 可以构成多分支
- `if (条件表达式) {语句1} else if (条件表达式) {语句2;} ... else {语句3;} `

6.  switch 语句

- switch 语句专门用来设计多分支条件结构。与 else/if 多分支结构相比，switch 结构更加简介，执行效率更高。
- 语法 `switch（表达式）{case value1：语句1；break; case value2：语句2；break; …………default：语句 }`
- switch 语句根据表达式的值，一次次与 case 后的表达式的 value 值进行比较。如果全等，则执行其后的语句段，如果不全等，则继续查找下一个 case。
- 在 switch 语句中，case 子句只是指明了执行的起点，但是没有指明终点，如果 case 后没有 break 语句，就会发生连续执行的情况，而忽略后边 case 的条件限制,所以我们要在每一个条件后书写 break,告诉程序,当前 switch 到此为止了
- switch 语句包含了一个可选的 default 语句(switch 的异常处理)，如果前边的 case 没有找到相等的条件，则执行 default 语句，它与 else 语句类似。
- case 后可以是一个空语句，把多个条件放在一起检测

7.  while 语句:

- while 语句是最基本的循环结构。语法格式如下：
- `while(判断式){语句}`
- 当判断式为真的时候，执行语句。执行结束之后再次进行判断，直到判断式为假，才跳出循环。
- 注意:!!!一定要在执行循环的过程中改变判断的条件,否则会进入死循环

8.  do while 循环:

- do/while 与 while 循环非常相似，区别在与表达式的值是每次循环结束后去检查，而不是开始去检查
- 因次 do/while 循环能够保证至少执行一次循环。而 while 就不一定了。

9.  for 循环:

- for(表达式 1;判断式 2;表达式 3){循环体}
- 执行过程
  1. 先执行表达式 1(一般是声明一个变量,控制循环次数的)
  2. 执行判断式 2(判断条件)
  3. 如果判断式 2 成立 则执行循环体,如果判断式不成立,则立马退出整个 for 循环
  4. 执行完循环体,则开始执行表达式 3(一般是对判断条件的变量做修改)
  5. 再次执行判断式 2,如果成立则再次执行循环体
  6. 依次类推,直到判断式不成立,则退出循环

10. break 语句:

- break 语句能够结束当前 for、for/in、while、do/while 或者 switch 语句的执行。
- 同时 break 可以接受一个可选的标签名，来决定跳出的结构语句。
- 如果没有设置标签名，则跳出当前最内层结构。

11. continue 语句

- continue 语句用在循环结构内，用于跳出本次循环中剩余的代码，继续执行下一次循环。
- 可以接受一个可选的标签名，来决定跳出的循环语句。

12. label 语句

- 在 JS 中，label 语句可以为一行语句添加标签，以方便在复杂的结构中设置跳转目标。
- 语法如下：
  - label 名:语句
  - label 可以是任意合法的标识符，然后使用冒号分割标签名与标签语句。
- label 和 break 或 continue 语句配合使用，主要应用在循环结构、多分支结构中，以便与跳出内层嵌套体。

13. 错误类型

- ECMA-262 规范了 7 种错误类型。其中 Error 是基类，其他 6 种错误类型是子类，都继承了基类。Error 类型的主要作用是自定义错误对象。
- Error：普通异常 。与 thorw 语句和 try/catch 语句一起使用，属性 name 可以读写异常类型，message 属性可以读写详细的错误信息。
- `!!!SyntaxError`：出现语法错误时抛出(比如: 1++)
- `!!!ReferenceError`：读取不存在的变量时抛出(console.log(a))
- `!!!TypeError`：值的类型发生错误的时候抛出(var a; a.b)
- `EvalError`：不正确使用 eval()方法时抛出
- `RangeError`：数字超出合法范围之抛出
- `URIError`：URI 编码和解码错误时抛出

14. 异常处理:

- try/catch/finally 语句是异常处理语句
- 语法`try{}catch(){}finally{}`
- 正常情况下，JS 按顺序执行 try 子句中的代码，如果没有异常发生，将会忽略 catch 跳转到 finally 子句继续执行。
- 如果在 try 子句运行错误，或者使用 throw 语句主动抛出异常，则执行 catch 子句中的代码，同时传入一个参数，就是 try 中错误的 Error 对象
- catch 接受的参数,有一个属性 message,可以得到精确错误信息
- 一般 try 是用来处理一些不可控制的错误(比如 网络请求 ....)

## 06. 函数

1. 什么是函数:

- 函数是一段被封装的代码，可以反复被调用。
- 函数的作用:1. 封装(整合一段代码) 2. 反复调用(让这段代码多次执行) 3.隔离(函数内部声明的变量只能自己内部使用)
- 函数身份:1. 函数 2. 对象(可以扩展属性和方法)

2. 定义函数的方法:

- 函数声明
  - 在 Javascript 中可以使用 function 语句声明函数
  - function 后跟函数名(一个标识符),函数名之后跟一个包含 0 个或多个参数(多个参数使用逗号间隔)的小括号,小括号后边跟一个代码块
- 函数表达式
  - 定义一个匿名函数(没有名字的函数),赋值给一个变量保存
- 实例化函数(很少使用)
  - 因为所有的函数都属于 Function 类,我们可以通过实例化(new)Function 类的方式创建一个函数
  - 实例化 Function 之后得到一个匿名函数,可以赋值给一个变量保存
  - Function 接受的所有参数都是字符串格式的,最后一个参数是函数体的字符串表示,前边所有的参数都是当前定义出来函数的参数

3. 函数调用方式:

- 直接加小括号调用,也被称作为默认调用(fn())
- 上下文对象调用(console.log())
- 实例化调用(new fn() 或者 new fn)【后边学习】
- 使用 call 或者 apply 方法调用【后边学习】

4. 函数的返回值

- 函数提供两个接口与外界的交互，其中参数作为入口，接受外界的信息。返回值作为出口，把运算结果反馈给外界。
- 在函数体内,使用 return 语句可以设置函数的返回值
- 如果函数不包含 return 语句,则执行完函数体内所有语句后,返回 undefiend 值
- return 的作用
  - 函数返回值
  - 停止当前函数的运行,直接退出函数
- 函数如果返回多个值呢?把多个值放在数组中或者对象中

5. 函数的参数:

- 参数是函数对外联系的唯一入口，用户只能通过参数来控制函数的运行。
- 参数分为形参和实参
  - 形参：在定义函数时，声明的参数变量,形参仅在函数内部可见(形参就是只能在当前函数内访问的变量)
  - 实参：在调用函数时，实际传入的值
- 注意事项
  - 函数的实参和形参的数量可以相同,也可以不相同
  - 如果函数的实参数量少于形参数量，那么多出来的形参会默认会 undefined
  - 如果函数实参数量多余形参数量，那么多出来的实参就不能通过形参访问(需要使用 arguments 访问)
  - 我们可以给可能不被传递的形参设置默认值
    1. `b = b ? b : 1;`
    2. `b = b || 1;`
    3. `b ||= 1`

6. arguments:

- arguments 对象表示当前所在函数的实参集合(对象),仅能够在函数体内可见,并可以直接访间。
- 参数对象是一个伪(类)数组。可以使用数组下标的形式访问每个实参,如参数[0]表示第一个实参
- arguments 拥有 length 属性,可以到的实参的长度
- 每一个函数也有一个 length 属性,代表当前函数形参的个数

7. 变量作用域:

- 变量作用域（scope）是指变量在程序中可以作用的有效范围。也称为变量的可见性。
- var 声明的变量,function 声明的变量,他们目前作用域的划分是使用函数来划分的
- 在函数外部的区域被称作为全局,在函数内部区域被称作局部
- 在函数外部(全局)声明的变量被称作为全局变量,在函数内部(局部)声明的变量被称作为局部变量
- 局部变量只能在当前所在的函数内部被访问,全部变量可以在程序的任何位置被访问

8. window 对象:

- 在 ECMA 规范中定义了一个顶层对象 Global 对象(包含了全局的一些属性或者方法,比如 isNaN 比如 parseInt)
- 但是在浏览器中没有实现 Global
- 浏览器让 window(窗口对象)扮演了 Global 角色,所以 window 对象就是目前 js 中的顶层对象
- 全局定义的变量和函数其实就是 window 的属性和方法
- 我们也可以通过 window.xx 来定义全局变量,或者使用全局变量
- 注意:全局变量在全局作用域内都是可见的,因此具有污染性。大量使用全局变量会降低程序的可靠性和效率,用户应该避免使用全局变量

9. 全局变量的定义方式:
1. 在全局作用域中直接声明一个变量,这个变量就是全局变量
1. 我们在任何位置给 window 对象扩展属性和方法,就是设置全局的变量和全局的函数(var 和 function 声明全局变量其实是 window 对象的属性或方法)
1. 直接给一个没有声明的变量赋值,则这个变量最终被设置为全局变量

1. 执行上下文:

- JS 引擎并不是一行行的解析和执行代码，而是一段段的去分析和执行,代码分段是代码分为 2 种类型:全局代码、函数代码
- 在执行某段 js 代码的时候，会进行一个准备工作,这个准备工作用专业的说法 叫“执行上下文”
- 准备工作包含:1. 开辟一个内存空间 2. 确定变量对象 3. 完成作用域链 4. 确定 this 指向
- 每执行一段代码，都会创建相对应的执行上下文，在脚本中可能存在多个执行上下文
- 因为有太多的执行上下文， JS 创建了一个执行上下文栈（stack） 用来管理执行上下文
- 当 js 开始解析程序的时候，最先遇到的全局代码，此时向执行上下文栈中 压入一个全局执行上下文，全局的一定是在页面被关闭以后才被清空
- 当执行一个函数的时候 会创建一个函数的执行上下文，并压入到执行上下文栈中，只要函数执行完成，会将函数从栈里弹出

11. 变量对象(声明提升)：

- 变量对象是 ECMAScript 规范术语。变量对象储存了在上下文中定义的变量和函数声明
- 在一个执行上下文中,变量对象才被激活,当前执行上下文中的变量或方法才能被使用
- 全局执行上下文的变量对象其实就是全局对象 window(全局的变量和函数就是 window 对象属性和方法)
- 进入执行上下文 不会立马执行代码，只进行分析
  - 此时首先第一步，变量对象包括了函数所有的形参和实参
  - 检查所有函数声明,将整个函数添加到变量对象中,如果变量对象已经有相同名字的属性，则完全替换
  - 检查所有变量声明,放在变量对象中,值为 undefined,如果变量名和已经声明的形参或函数相同，则变量声明不会干扰已经存在的这类属性
- 对于函数来说,如果是函数声明,则提升整个函数体,如果是函数表达式,则只提升变量

12. 作用域链：

- 作用域链的用途,是保证对 执行环境有权访问的所有变量和函数(变量对象) 的有序访问。
- 作用域链是在函数声明的时候产生的,在函数被调用的时候把当前函数的变量对象放在作用域链上,完成作用域链
- 作用域链的最前端一定是当前执行上下文中的变量对象，作用域链的最末端一定是 window
- 标识符解析是沿着作用域链一级一级地搜索变量对象的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯,直至找到标识符为止(如果找不到标识符,通常会导致错误发生)

13. this 指向:

- 简要说明:this 永远指向其所在函数的调用者,如果找不到调用者,则执行全局对象 window,同一个函数调用的方式不同,this 的指向也是不同的
- 判断 this
  1. 判断有没有 call 和 apply(未来再讲)
  2. 判断有没有 new 调用(未来再讲)
  3. 判断调用的时候(除了上边两种情况,函数名()就是调用函数),有没有上下文对象,如果有,则 this 指向上下文对象
  4. 函数默认调用(自己调用),this 指向 window

14. 理解:

- 执行函数--->执行上下文(开辟空间,确定变量对象,完成作用域链,确定 this 指向)
- 变量对象-->把当前函数的 形参实参 函数声明 变量声明都提升到函数的最前边,放在变量对象 vo 中,然后才会执行代码,在执行代码的过程中,如果需要使用变量,则会在自己函数的变量对象中查找
- 所以无论哪一个变量都是存放在声明所在的函数的变量对象中,我们找变量也都是在变量对象中查找
- 变量对象先确定形参和实参,然后把当前上下文内部的函数声明(function xx(){})整体提升到变量对象中,如果有重名,则直接覆盖原来的值。最后提升所有的变量声明(var xx),把变量作为属性放在变量对象中(注意:只提升声明,赋值不会提升,只有运行到了才能赋值),在提升变量的时候如果重名,则自己失效
- 函数在定义的时候就产生了作用域链,根据声明的位置产生的作用域链,但是当前的函数并没有执行,所以当前函数没有变量对象,所以此时的作用域链是不完整的,缺了当前函数的变量对象
- 当前函数一旦被调用(无论在哪个位置),就会把自己的变量对象 添加到声明函数时创建的作用域链的最前端,此时作用域链完成
- 当我们在使用变量的时候,先找自身的变量对象,如果找不到,则沿着作用域链向上一级寻找,直到找到位置

## 07. 字符串

字符串所有的方法都不会改变原字符串,而是返回新的字符串 01. 拼接字符串:

- 拼接字符串最直观的方式就是使用`+`拼接,也是最推荐的一种方式
- 调用某个字符串的 concat 方法,可以把 concat 接受的一个或多个参数拼接在字符串的后边,并返回

2.  字符串截取方法:

- slice: 截取字符串

  - 接受两个参数,分别代表起始下标和结束下标(不包含结束下标)
  - 只写一个参数,代表开始截取的起始位置,然后直接截取到末尾
  - 第一个参数为负,代表从后向前数开始截取的位置,截取还是向后截
  - 第二个参数为负,代表从后向前数确定结束位置

- substring

  - 接受两个参数,分别代表起始下标和结束下标(不包含结束下标)
  - 只写一个参数,代表开始截取的起始位置,然后直接截取到末尾
  - substring 会忽略负值,把负值转为 0
  - 如果第二个参数小于第一个参数,则交换两个参数的顺序(起始和结束位置相比较的大小无法确定的时候可以使用 substring)

- substr(es 不太推荐使用)
  - 接受两个参数,分别代表起始下标和截取的长度
  - 只写一个参数,代表开始截取的起始位置,然后直接截取到末尾
  - 第一个参数可以书写负值,从字符串的末尾向前数

3.  字符串大小写转换

- toLowerCase():把字符串中所有的字符转小写
- toUpperCase():把字符串中所有的字符转大写

4.  字符串查找方法:

- 下标方式(推荐)，直接通过 需计算成员访问运算符([]) 获取某个下标的字符串，如果获取不到，则返回 undefined
- charAt 方法,字符串的 charAt 方法可以接受一个 下标 作为参数,获取某个下标的字符串,如果获取不到则返回空字符串
- indexOf 方法,接受一个字符串作为参数,判断调用 indexOf 方法的字符串中是否存在当前字符串参数,如果存在则返回第一次出现的下标,否则返回-1
- lastIndexOf 方法,和 lastIndex 方法一致,只不过是从后向前依次查找,然后返回第一个查找到的下标(下标永远都是从前向后从 0 开始的)
- search 方法和 indexOf 的功能是相同的，查找指定字符串第一次出现的位置,但是可以接受正则表达式查找,search 的底层仍然使用的是 indexOf,所以如果不是正则查找,则使用 indexOf 即可
- macth 方法,接受正则表达式作为参数,把所有查找到的字符串,组成一个数组返回,如果一个都查不到,则返回 null
- replace 方法,用来把查找到的字符串进行替换,接受的第一个参数是正则用来查找被替换的字符串,第二个参数是替换的字符串(第二个参数也可以是一个函数,函数的参数就是当次查找的值,函数的返回值就是当次替换的值)
- includes:如果使用 indexOf 判断某个字符串是否存在,只能通过判断返回值是否不等于-1 实现。includes 就是判断某个字符串是否存在,存在返回 true,否则返回 false

5.  字符串转数组方法： split():

- 如果没有传递任何参数，或者参数字符串在字符串中不存在，则把字符串整体作为数组的一个值
- 如果参数是一个空字符串，则把字符串的每一个字符串作为数组的每一个值
- 如果参数是一个字符，则以这个字符为分割，切割字符串

6.  去除字符串首尾空白字符

- trimStart():去除字符串前边的空白字符
- trimeEnd():去除字符串后边空白字符
- trim():去除字符串两边的空白字符

## 08. Math

1.  Math 对象提供了很多关于数学计算的属性和方法,Math 对象的属性主要是提供了一些数学常用的固定值

- Math.E // 2.718281828459045（自然底数 无限不循环小数）lim(1+1/n)^n=e ,n→+∞
- Math.LN2 // 0.6931471805599453（2 的自然对数）
- Math.LN10 // 2.302585092994046（10 的自然对数）
- Math.LOG2E // 1.4426950408889634（2 为底 e 的对数）
- Math.LOG10E // 0.4342944819032518
- Math.PI // 3.141592653589793
- Math.SQRT1_2 // 0.7071067811865476
- Math.SQRT2 // 1.4142135623730951

2.  Math 对象提供的方法主要是为了对数字的计算

- Math.abs():求一个值的绝对值
- Math.ceil():向上取整(取靠近的大的整数)
- Math.floor():向下取整(取靠近的小的整数)
- Math.round():四舍五入
  - 正数的时候，当小数点后一位大于等于 5 的时候 整数部分加 1 小于 5 的时候 整数部分不变
  - 负数的时候 当小数点后一位 大于 5 的时候 整数减 1, 小于等于 5 的时候 整数不变\
- Math.min()和 Math.max() 计算一组数值中的最大值和最小值
- Math.pow():返回以第一个参数为底数，第二个参数为幂的指数值(现在常用的是 \*\* 运算符)
- Math.sqrt(): 返回参数的平方根，如果参数是负数，返回 NaN
- Math.sin(),Math.cos(),Math.tan():求三角函数的值,参数不是角度而是弧度
- Math.random():求随机数 生成 `[0,1)` （大于等于 0 小于 1） 小数随机数
