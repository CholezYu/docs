# HTML

## H5 新特性有哪些

- 新增了新的语义化标签：

  - 例如 header、main、footer、nav、aside
  
  - 合理使用语义化标签，可以使 html 结构更清晰，便于团队开发和维护；有利于 SEO 搜索引擎优化。
  
  - 搜索引擎优化的作用就是提高网站在搜索引擎的排名。
  
  1. 优化方式可以使用语义化标签，例如 img 标签的 alt 属性、title 标签、h 标签；
  
  2. 设置 meta 标签的 keword 和 description 属性，设置一些关键字和描述；
  
  3. 还可以建立更多跳转到自己网站的链接，喂养爬虫；提高网站加载速度，让爬虫在一定时间内访问更多网页；
  
  4. 或者使用服务端渲染。
  
- 还新增了一些表单元素：

  - 例如调色板、日历控件
  
  - 但是它们的样式不好控制，在项目中一般会使用一些 UI 组件库，例如 elementUI、Ant Design
  
- 比较常用的还有本地存储：

  - localStorage 持久化存储；sessionStorage 会话存储，浏览器关闭时会话结束，数据被清除
  
  - 可以使用 localStorage 做免登录。登录时将 token 永久存储在本地，使用 token 时优先从本地读取
  
- 还新增了音视频标签，以及流媒体播放技术

- 还新增了 canvas ，用来绘制图形，我在项目中使用过它的一个封装库 echarts，做大屏数据可视化

- 还有 Web Worker：

  - 可以开启分线程，将大量计算工作交给分线程，优化性能

  - 实例化一个 worker 对象，创建分线程执行一个 js 文件
  
  - 主线程通过 postMessage 方法向分线程发送数据，通过监听 onmessage 事件接收数据
  
  - 分线程也是通过 `self.postMessage` 向主线程发送数据，监听 `self.onmessage` 事件接收数据

## src 和 href 的区别

- 资源类型与作用结果不同：

  - 请求 src 资源时会将其指向的资源下载并应用到文档中，替换当前元素。例如 script、img、iframe 标签

  - href 会指向网络资源所在位置，建立资源和文档之间的链接。例如 link 或 a 标签

- 浏览器解析方式不同：

  - 当浏览器解析到 src，会暂停其他资源的下载和处理，阻塞当前页面渲染。所以建议把 script 标签放在底部

  - 如果在文档中添加 href，浏览器会识别该文档为 css 文件，会并行下载资源并且不会停止对当前文档的处理

## 说说块元素和行内元素

- 块元素

  - 常见的块元素有 div、p、ul、table、form

  - 块元素独占一行，可以设置宽高和内外边距，且宽度默认为父元素的 100%；

  - 块元素可以嵌套块元素和行内元素，但是 p、h、dt标签不行

- 行内元素

  - 常见的行内元素有 span、a、strong、em

  - 行内元素不独占一行，不能设置宽高，可以设置水平方向的内外边距，宽度默认为内容的宽度

  - 行内元素只能嵌套行内元素，但是 a 标签可以嵌套除了 a 标签块元素和行内元素

- 行内块元素

  - 常见的行内块元素有 input、textarea

  - 行内块元素不独占一行，可以设置宽高和内外边距，宽度默认为内容的宽度

- 行内替换元素

  - img 是特殊的行内元素，可以设置宽高

## 谈谈 iframe

iframe 标签就是在一个页面中嵌套另一个页面

- 同源情况下

  - 父页面可以访问子页面的内容，可以通过 `iframe.contentWindow` 访问子页面的 window 属性；

  - 但是需要使用 onload 事件监听子页面加载完毕，才能操作子页面的元素
  
- 非同源情况下

  - 父页面和子页面都是通过 `postMessage` 方法发送数据，通过监听 `onmessage` 事件接收数据






# CSS

## C3 新特性有哪些

新增了属性名选择器、伪类选择器和伪元素选择器

圆角边框

不透明度

文本阴影和盒子阴影

2D 转换：平移、旋转、缩放

过渡和动画

媒体查询（@media 用来做响应式布局）

## 谈谈 BFC

BFC 称为块级格式化上下文。是一个独立的渲染区域，让处于 BFC 内部的元素与外部元素相互隔离，互不影响

开启 BFC 可以解决父元素外边距塌陷问题，和浮动导致的父元素高度塌陷问题

开启 BFC 的方式有：浮动、绝对定位或固定定位、设置 overflow、设置为行内块元素

## CSS 预处理器

CSS 预处理器有 Sass、Less 和 Stylus，它们为 CSS 添加了一些编程特性，让我们可以对 CSS 进行复用

我在项目中使用过 Sass，它可以定义变量或者常量，在项目中使用 $ 定义一些主题颜色和字体大小；

Sass 还允许代码嵌套，可读性高；

还可以通过 @mixin 定义一些混入，例如用省略号代替多行文本溢出，它有点类似于函数，提高样式的可复用性；

还可以通过 @extend 实现继承

## 谈谈 Flex 布局

Flex 布局又称为弹性布局。弹性容器中存在主轴和侧轴，默认情况下，主轴水平向右，侧轴垂直向下

容器的属性：

`flex-direction` 设置主轴方向

`flex-wrap` 设置是否换行

`justify-content` 设置弹性元素在主轴的排列方式

`align-items` 设置弹性元素在侧轴的排列方式

`align-content` 设置换行的弹性元素在侧轴的排列方式

弹性元素的属性：

`align-self` 设置弹性元素自身的排列方式

`order` 设置弹性元素的排列顺序

`flex-grow` 给弹性元素按比例分配富余空间，默认为 0

`flex-shrink` 按比例压缩弹性元素，默认为 1

`flex-basis` 设置弹性元素被压缩时最小的大小，默认为 auto

`flex: 1` 是 `flex-grow: 1` `flex-shrink: 1` `flex-basis: 0` 的简写；表示弹性元素会等比例分配富余空间或等比例压缩，且被压缩时最小的大小为 0

## 如何让元素水平垂直居中

给父元素设置相对定位，给子元素设置绝对定位，给子元素设置 left 和 top 为 50%，并水平和垂直平移 -50%；

将容器设置为弹性容器，设置弹性元素在主轴和侧轴上居中





# JavaScript

## JS 的数据类型有哪些

- 基本数据类型有：

  - number、boolean、string、undefined、null、symbol、bigint
  
  - null 表示声明一个变量时，将要赋值为对象，暂时赋值为 null
  
  - undefined 表示访问对象的属性不存在，或声明变量未赋值

- 引用数据类型有：

  - function、object、array

## 如何判断 JS 的数据类型

- typeof：

  - 可以判断大部分数据类型，但是无法区分 null、对象、数组

- instanceof：

  - 判断构造函数的原型对象是否在实例对象的原型链上

- Object.prototype.toString.call：

  - 可以判断所有数据类型

## 说说常见的数组方法

- 变更方法：

  - push、pop、unshift、shift、splice、reverse、sort

- 遍历方法：

  - forEach、filter、map、reduce、find、findIndex、every、some

- 其他方法：

  - slice、join、concat、indexOf、includes

## 作用域和作用域链

- 作用域：

  - 作用域是一个变量可以合法使用的区域。作用是为了隔离变量，避免变量重名产生的冲突

  - 作用域分为全局作用域、函数作用域、块级作用域

- 作用域链：

  - 作用域链是多个作用域形成的一条链。用于查找变量

  - 查找变量时，先在自身作用域查找，再沿着作用域链向外层查找，最终找到全局作用域，如果都找不到就会报错

## 说说对闭包的理解

- 闭包是什么：

  - 闭包是一个引用外部函数变量的 closure 对象，存在内部函数中，可以通过断点调试查看

- 产生闭包的条件有：

  - 函数嵌套、内部函数引用外部函数的变量、外部函数被调用

- 闭包的优点：

  - 闭包可以延长变量的生命周期，可以在函数外部操作函数内部的数据

- 闭包的缺点：

  - 闭包可能会导致内存泄漏。可以将内部函数变成垃圾对象被回收，由于闭包存在内部函数中，所以闭包也会被回收

- 闭包的生命周期：

  - 闭包是在外部函数被调用时产生的，在内部函数变成垃圾对象时死亡

## 谈谈 this 指向

- 普通函数：

  - 直接调用函数，this 指向 window，严格模式下为 undefined
  
  - 对象调用方法，this 指向该对象
  
  - new 关键字调用，this 指向实例对象
  
  - call、apply 调用，this 指向第一个参数
  
- 特殊函数：

  - 箭头函数中，this 指向函数声明所在的作用域
  
  - 事件函数中，this 指向绑定事件的 DOM 元素
  
  - 定时器回调，this 指向 window
  
  - 生命周期函数，this 指向组件实例对象

## 说说原型和原型链

- 原型：

  - 原型指的是两个原型属性，显示原型（原型对象）和隐式原型
  
  - 所有非箭头函数都有一个原型对象，这个原型对象上有一个 constructor 属性指向函数本身
  
  - 每个实例对象都有一个隐式原型，它指向对应构造函数的原型对象
  
- 原型链是什么：

  - 因为实例对象的隐式原型指向构造函数的原型对象，而这个原型对象上又有一个隐式原型；
  
  - 它可能会指向父类构造函数的原型对象；也可能会指向 Object 的原型对象。
  
  - 它们会形成一条链，最终指向 Object 的原型对象。我们把这条链称为原型链。
  
  - 因为 Object 的原型对象的隐式原型为 null，根据定义，null 没有原型对象，所以它是原型链的尽头
  
- 原型链的作用：

  - 原型链用于查找对象的属性和方法。查找时，先在对象自身上查找，再沿着原型链向上一级查找；
  
  - 最终找到 Object 的原型对象。如果在 Object 的原型对象上没有找到，就返回 undefined
  
  - 利用原型链可以实现继承；或者将实例对象的公共方法挂载到构造函数的原型对象上，例如 Vue 的事件总线

## 说说 JS 的垃圾回收机制



## 谈谈 JS 的事件循环机制

事件循环是异步的实现方式。浏览器使用异步的方式解决了由于 JS 是单线程造成的阻塞问题，所以有了事件循环

浏览器主要的进程有：浏览器进程、网络进程、渲染进程。

渲染进程中又包含了多个线程，例如：

- GUI 渲染线程：

  - 负责渲染和绘制页面，将 HTML、CSS 和图像等内容呈现到页面
  
- JS 引擎线程：

  - 负责解析和执行 JS 代码，对页面进行 DOM 操作和事件处理
  
- 事件触发线程：

  - 负责处理用户交互产生的事件，如鼠标点击、键盘输入等。当事件被触发时，会将事件添加到任务队列中
  
- 定时器线程：

  - 负责管理定时器。当定时器到期时，会将相应的任务添加到任务队列中等待执行
  
- 渲染主线程：

  - 负责协调以上所有线程的工作，包括将待处理的事件和任务分发给相应的线程进行处理

渲染进程启动后，会开启一个渲染主线程，它会进入一个无限 for 循环

## ES6 的常用语法有哪些

- 声明扩展，let 和 const

- 解构赋值

- 箭头函数

  - this 指向函数声明时所在的作用域，而不是函数体内的作用域。也就是会继承作用域链上一层的 this
  
  - 没有原型对象。也就是说，不能使用 new 关键字，不可以作为构造函数

  - 没有 arguments 对象，使用 rest 参数代替
  
  - 不能使用 yield 命令，因此箭头函数不能作为 Generator 函数

- 展开运算符

- 模块化

- Promise：[谈谈 Promise](#谈谈 Promise)

- async 和 await

- Proxy

## 谈谈 Promise

- Promise 是异步编程的一种解决方案，解决了异步回调地狱问题

- Promise 的状态：

  - Promise 有三种状态，pending、fulfilled、rejected；

  - Promise 的状态只能从 pending 变为 fulfilled 或者 rejected，一旦改变状态就会凝固；

  - 可以通过 resolve 或 reject 方法改变 Promise 的状态
  
  - Promise 实例对象的 then 和 catch 方法可以处理异步结果；

  - 我们一般使用 then 处理成功结果，使用 catch 处理失败结果。当然 then 也可以处理失败结果；

  - then 和 catch 都会返回一个新的 Promise 对象，所以我们可以进行链式调用；

- 异常穿透：

  - 在链式调用中，如果 then 方法无法处理上一步的异常结果，会出现异常穿透，直到被 catch 捕获

- then 的返回值：

  - 通常情况下，then 都会返回一个成功状态，且值为 undefined 的 Promise；

  - 如果我们 return 一个普通值，then 会返回一个成功状态，且值为这个普通值的 Promise；

  - 如果我们 return 一个 Promise，then 会返回这个 Promise，状态和值都和它保持一致；

  - 只有当 then 中的代码出错了，或者我们抛出一个错误，then 才会返回一个失败状态的 Promise

- 中断 Promise 链：

  - 我们可以返回一个 pending 状态的 Promise 来中断 Promise 链

- Promise 的静态方法：

  - Promise.all：当数组中的所有 Promise 都成功时，Promise.all 才会成功。可以用来处理并发请求

  - Promise.allSettled：不管成功或失败都能得到结果。也可以用来处理并发请求

  - Promise.race：返回第一个改变状态的 Promise

## 谈谈深拷贝和浅拷贝

- 深拷贝和浅拷贝都是复制对象方式

- 它们的区别是：

  - 如果原始对象中有一些属性的值是引用类型，那么浅拷贝会复制它的地址；
  
  - 而深拷贝会复制它的值，并且指向一个新的地址。
  
  - 修改浅拷贝对象中的引用类型属性，会改变原始对象中对应的属性；
  
  - 而深拷贝就不会有这个问题，它拷贝的对象和原始对象互不影响

- 在代码中实现：

  - 浅拷贝可以使用展开运算符、数组的 slice 方法或 Object.assign 实现；

  - 深拷贝的话，我一般会使用 lodash 的 cloneDeep 方法

