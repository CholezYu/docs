# 动态绑定 v-bind

## 字符串语法

```vue
<!-- 动态绑定类名 -->
<div v-bind:class="isActive ? 'active' : ''"></div>
```

## 对象语法

```vue
<!-- 动态绑定类名 -->
<div v-bind:class="{ active: isActive }"></div>

<!-- 动态绑定样式 -->
<div :style="{ color: 'red', fontSize: '13px' }"></div>
```

## 数组语法

```vue
<!-- 动态绑定类名 -->
<div v-bind:class="['active', 'visible']"></div>

<!-- 动态绑定样式 -->
<div :style="[{ color: 'red' }, { fontSize: '13px' }]"></div>
```





# 条件渲染 v-if & v-show

## 添加 & 删除 v-if

v-if 初始渲染表达式的值为 "真" 的元素，在切换时销毁 DOM 元素

```vue
<span v-if="score >= 90">优秀</span>
<span v-else-if="score >= 80">良好</span>
<span v-else-if="score >= 60">及格</span>
<span v-else>不及格</span>
```

## 显示 & 隐藏 v-show

v-show 初始渲染所有元素，但只显示表达式的值为 "真" 的元素，在切换时隐藏 DOM 元素 

```vue
<span v-show="true">{{ name }}</span><!-- 显示 -->
<span v-show="false">{{ name }}</span><!-- display: none -->
```

## 使用 template 渲染分组

在 `<template>` 标签上条件渲染多个元素，最终的渲染结果不包含 \<template>

```vue
<template v-if="true">
  <h1>Title</h1>
  <p>Paragraph</p>
</template>
```

## v-if vs v-show

- v-if 有更高的切换开销，v-show 有更高的初始渲染开销

- 如果在运行时条件很少改变，使用 v-if 较好；如果需要频繁地切换，使用 v-show 较好

- v-if 支持 \<template>， v-show 不支持 \<template>





# 列表渲染 v-for

## 遍历列表

```vue
<!-- 遍历数组 -->
<li v-for="item, index in array" :key="item.id"></li>

<!-- 遍历对象, 按 Object.keys() 的结果遍历 -->
<li v-for="value, key, index in object" :key="value.id"></li>

<!-- 遍历数字, item: 1 to target, index: 0 to target -->
<li v-for="item, index in number"></li>

<!-- 遍历字符串 -->
<li v-for="item, index in string"></li>
```

## 使用 template 渲染分组

在 `<template>` 标签上列表渲染多个元素，最终的渲染结果不包含 \<template>

```vue
<template v-for="item in items">
  <li>{{ item.name }}</li>
  <li>{{ item.age }}</li>
</template>
```

## v-for 与 v-if 一起使用

当它们处于同一节点：

- v-for 的优先级高于 v-if，这意味着在编译阶段会先渲染所有节点，再根据条件渲染部分节点，造成性能浪费

- 可能造成不明确的预期结果



我们一般会这么做：

- 对于所有节点条件渲染，使用计算属性，返回过滤后的列表

- 对于部分节点条件渲染，将 v-if 移至外层元素上





# 事件处理 v-on

## 事件监听

```vue
<button v-on:click="count++"></button>
```

## 事件参数

> 事件函数默认接收 event 事件对象作为参数
>
> 在 v-on 的插值语法区域，默认存在一个 $event 事件对象，可以将其作为参数传递给事件函数

```vue
<!-- event -->
<button @click="click"></button>

<!-- undefined -->
<button @click="click()"></button>

<!-- event -->
<button @click="click($event)"></button>

<!-- param event -->
<button @click="click(param, $event)"></button>
```

## 事件修饰符

- `.prevent`：阻止默认行为，调用 `event.preventDefault()`

- `.stop`：阻止事件传播，调用 `event.stopPropagation()`

- `.once`：只触发一次事件函数

- `.capture`：使用事件捕获模式

- `.self`：当 `event.target` 是当前操作的元素时触发事件函数

## 按键修饰符

`keyup.{keyCode | keyAlias}` - 监听键盘事件

```vue
<!-- 按键码 -->
<input @keyup.13="onEnter" />

<!-- 按键别名 -->
<input @keyup.enter="onEnter" />
```





# 表单绑定 v-model

## 原始模式

输入框：使用 value 属性和 input 事件

```vue
<!-- input -->
<input type="text" :value="message" @input="message = $event.target.value" />

<!-- textarea -->
<textarea :value="message" @input="message = $event.target.value"></textarea>
```

多选框：使用 checked 属性和 change 事件

```vue
<!-- checkbox -->
<input type="checkbox" :checked="isAgree" @input="isAgree = $event.target.checked" />
```

单选框：使用 checked 属性和 change 事件

```vue
<!-- radio -->
<input type="radio" value="男" :checked="sex" @change="sex = $event.target.checked" />
<input type="radio" value="女" :checked="sex" @change="sex = $event.target.checked" />
```

下拉框：使用 value 属性和 change 事件

```vue
<!-- select -->
<select :value="city" @input="city = $event.target.value">
  <option value="北京">北京</option>
  <option value="上海">上海</option>
  <option value="深圳">深圳</option>
  <option value="广州">广州</option>
</select>
```

## 语法糖模式

当需要绑定 props 中的数据时，无法使用 v-model (会修改父组件数据)，则使用 v-bind + v-on 模式

```vue
<!-- 文本框 -->
<input type="text" v-model="message" />

<!-- 文本域 -->
<textarea v-model="message"></textarea>
```

```vue
<!-- 一个多选框时，绑定布尔值 -->
<input type="checkbox" v-model="isAgree" />

<!-- 多个多选框时，绑定一个数组 -->
<input type="checkbox" value="篮球" v-model="hobbies" />
<input type="checkbox" value="足球" v-model="hobbies" />
<input type="checkbox" value="排球" v-model="hobbies" />
```

```vue
<!-- 单选框 -->
<input type="radio" value="男" v-model="sex" />
<input type="radio" value="女" v-model="sex" />
```

```vue
<!-- 下拉框单选时, 绑定一个字符串 -->
<select v-model="fruit">
  <option value="苹果">苹果</option>
  <option value="香蕉">香蕉</option>
  <option value="芒果">芒果</option>
  <option value="葡萄">葡萄</option>
</select>

<!-- 下拉框多选时, 绑定一个数组 -->
<select v-model="fruits" multiple>
  <option value="苹果">苹果</option>
  <option value="香蕉">香蕉</option>
  <option value="芒果">芒果</option>
  <option value="葡萄">葡萄</option>
</select>
```

## 修饰符

- `.lazy`：失去焦点或按下回车时才会更新数据，使用 change 事件。默认为 input 事件

- `.number`：将输入的字符串转为有效的数字 (parseFloat)，通常配合 number 输入框使用

- `.trim`：失去焦点或按下回车时清除输入框首尾空格





# 其他指令

## v-text

更新元素的 textContent。如果要更新部分 textContent，需要使用插值语法

```vue
<span v-text="message"></span>
<!-- 效果相同 -->
<span>{{ message }}</span>
```

## v-html

更新元素的 innerHTML。将数据按照 HTML 格式解析并渲染

```vue
<span v-html="<a href='https://www.baidu.com'>百度一下</a>"></span>
```

## v-cloak

与 CSS `[v-cloak] { display: none }` 一起使用，可以隐藏未编译的插值语法，指令会在编译结束后消失

```css
[v-cloak] {
  display: none
}
```

```vue
<!-- 不会显示, 直到编译结束 -->
<span v-cloak>{{ message }}</span>
```

## v-once

只渲染一次元素和组件，跳过随后的所有重新渲染

## v-pre

跳过这个元素和子元素的编译过程。用于没有指令或 Mustache 的节点，加快编译

```html
<!-- 跳过编译过程，加快编译 -->
<span v-pre>hello</span>

<!-- 检查是否有 Vue 语法 -->
<span>{{ message }}</span>
```





# 计算属性 computed

## getter & setter

```js
computed: {
  fullName: {
    get() {
      return this.firstName + " " + this.lastName
    },
    set(value) {
      const [firstName, lastName] = value.split(" ")
      this.firstName = firstName
      this.lastName = lastName
    }
  }
}
```

## computed vs methods

> 计算属性会基于响应式依赖进行缓存，只有在依赖的响应式属性改变时计算属性才会更新
>
> 只要访问的 computed 没有发生改变，多次访问会返回缓存的计算结果；而多次调用 methods 会重新执行函数

`Date.now()` 不是响应式依赖，所以计算属性不会更新

```js
computed: {
  now() {
    return Date.now()
  }
}
```

## computed vs watch

> 通常情况下，计算属性比侦听属性更加方便
>
> 但是 computed 不能用于异步操作，否则计算结果会返回给异步回调；而 watch 可以用于异步操作

计算属性

```js
computed: {
  fullName() {
    setTimeout(() => {
      return this.firstName + " " + this.lastName  // 返回给定时器回调
    })
  }
}
```

侦听属性

```js
watch: {
  firstName(value) {
    setTimeout(() => {
      this.fullName = value + " " + this.lastName  // 可以执行异步操作
    })
  },
  lastName(value) {
    setTimeout(() => {
      this.fullName = this.firstName + " " + value  // 可以执行异步操作
    })
  }
}
```





# 侦听属性 watch

## 基本使用

侦听 data 或 computed 中的属性，当属性变化时执行回调

```js
data: {
  count: 1
},
watch: {
  count: {
    handler(value, oldValue) {
      // do something...
    }
  }
}
```

侦听 data 中属性内部的属性，键名需要写成字符串形式

```js
data: {
  numbers: {
    count: 1
  }
},
watch: {
  "numbers.count": {
    handler() { /* ... */ }
  }
}
```

## 立即侦听

`immediate: true` - 侦听开始后 (初始化渲染) 立即调用 handler

```js
data: {
  count: 1
},
watch: {
  count: {
    immediate: true,
    handler(value, oldValue) { /* ... */ }
  }
}
```

## 深度侦听

`deep: true` - 侦听 data 中的属性与其内部的属性

```js
data: {
  numbers: {
    count: 1
  }
},
watch: {
  numbers: {
    deep: true,
    handler() { /* ... */ }
  }
}
```

## vm.$watch

Vue 的实例方法

```js
this.$watch("count", (value, oldValue) => {
  // ...
})

// or

this.$watch("count", {
  handler(value, oldValue) {
    // ...
  }
})
```





# 动态更新

> Vue 不会为被监听的数组元素绑定 getter 和 setter，所以更新数组不会触发视图更新

## 对象更新方法

- 直接为对象添加属性没有响应式

- 直接删除对象的属性没有响应式

- 为对象的属性重新赋值具有响应式

- 为对象重新赋值具有响应式

## 数组变更方法

Vue 将被监听的数组的变更方法进行了封装 (调用对应的原生方法更新数组，然后重新解析模板并更新视图)

所以使用以下方法更新数组会触发视图更新

- `.push()`

- `.pop()`

- `.shift()`

- `.unshift()`

- `.splice()`

- `.sort()`

- `.reverse()`

## 数组替换方法

使用非变更方法更新数组也会更新视图，但是它们不会变更原数组，而是返回新数组，可以用新数组替换原数组

- `.filter()`

- `.concat()`

- `.slice()`

## 其他更新方法

### Vue.set

为对象添加一个响应式属性，并触发视图更新

```js
Vue.set(vm.person, "sex", "男")
```

### Vue.delete

删除对象的一个响应式属性，并触发视图更新

```js
Vue.delete(vm.person, "sex")
```

### vm.$set

Vue 的实例方法

```js
this.$set(this.person, "sex", "男")
```

### vm.$delete

Vue 的实例方法

```js
this.$delete(this.person, "sex")
```





# 生命周期

## 初始化流程

\>> new Vue => 初始化事件和生命周期 => `beforeCreate` => 初始化数据注入和数据代理 => `created`

### beforeCreate

数据初始化和数据劫持（将数据转化为响应式数据）之前被调用

> 无法通过 vm 访问 data、methods、computed、watch 等

### created

数据初始化和数据劫持（将数据化转为响应式数据）之后被调用

> 可以通过 vm 访问 data、methods、computed、watch 等

## 编译流程

- 判断 Vue 是否配置 el 选项

  - 没有 el 选项，则等待使用 `$mount` 提供 el 选项

  - 存在 el 选项，再判断是否配置 template 选项

    - 如果有 template 选项，则编译模板得到 render 函数，返回虚拟 DOM

    - 如果没有 template 选项，则将 el 挂载容器的 outerHTML 作为模板进行编译

## 挂载流程

\>> 模板未解析，视图未更新 => `beforeMount` => render 函数返回虚拟 DOM，并转为真实 DOM => `mounted`

### beforeMount

挂载之前被调用。render 函数首次被调用

> 视图呈现的是未被解析的模板。DOM 操作无效，因为 Vue 即将把虚拟 DOM 转为真实 DOM 插入到页面

### mounted★

挂载之后被调用。一般在这个阶段进行 **开启定时器、发送网络请求、订阅消息、监听自定义事件** 等操作

> 视图呈现的是 Vue 编译后的 DOM。尽量避免 DOM 操作

## 更新流程

\>> 数据改变，视图未更新 => `beforeUpdate` => 使用 patch 算法（函数）比较新旧虚拟 DOM => `updated`

### beforeUpdate

数据更新之后，视图更新之前被调用

### updated

数据和视图都完成更新之后被调用

## 销毁流程

### beforeDestroy★

实例销毁之前被调用。一般在这个阶段进行 **关闭定时器、取消订阅、移除自定义事件** 等操作

> 实例中的 data、methods、指令等都可使用，但是没有任何意义

### destroyed

实例销毁之后被调用

> 实例中的所有指令被解除绑定，所有的自定义事件监听器被移除，所有的子组件也都被销毁





# 源码解析

## diff 算法

什么是 diff 算法？

- diff 算法就是比较新旧 DOM 树，寻找差异的算法，在源码中通过 `patch` 函数实现，所以也称为 patch 算法



diff 算法比较思路：

- **深度优先，同级比较**



执行过程：

- 当组件内部的响应式数据发生更新的时候，就会执行 Vue 内部的 `updateComponent` 函数，在函数内部先执行 `_render` 函数生成新的虚拟 DOM，将其作为参数传递给 `_update` 函数，并执行 `_update` 函数

- 在 `_update` 函数中，先定义一个变量保存旧的虚拟 DOM (`vm._vnode`)，然后将新的虚拟 DOM 赋值给 `vm._vnode`，此时 `_update` 函数中存在新旧虚拟 DOM，最后使用 `patch` 函数对新旧虚拟 DOM 进行比较



`patch` 比较过程：

- `patch` 函数内部首先使用 `sameVnode` 方法比较两个节点的**标签类型**和 **key** 以及表单元素的 **type** 是否相同

  - 如果相同，则进入更新流程
  
    - 把旧节点的真实 DOM 拿到新节点的位置复用
    
    - 对比新旧节点的（标签）属性是否相同，如果不同则更新
    
    - 比较子节点
    
  - 如果不相同，直接根据新节点创建元素，删除旧元素



比较子节点：

- Vue 使用四个指针分别指向新旧子节点列表的首尾节点

- 首先比较新旧树中头指针指向的节点

  - 如果相同则进入更新流程。头指针向后位移，继续比较

- 如果不同，则比较新旧树中尾指针指向的节点

  - 如果相同则进入更新流程...

- 如果不同，则交叉比较新旧树中头指针和尾指针指向的节点

  - 如果相同则进入更新流程...

- 如果以上比较都不相同，则以新树中头指针指向的节点为基础，循环旧虚拟 DOM 节点，查找是否存在相同节点

  - 如果存在则复用，进入更新流程
  
  - 如果不存在，说明该节点为新创建的，将该节点转为真实 DOM

- 当新树的头指针超过尾指针的时候，比较结束，删除旧树中的剩余节点



key 的作用：

- 在新旧虚拟 DOM 对比更新的时候，diff 算法默认采用 "就地更新" 原则

- 多个子节点比较的时候，如果没有 key 属性，默认都是 undefined，所以每个新旧虚拟 DOM 的 key 都相同，就会简单地按照节点的顺序依次比较。如果新旧节点是顺序的不同，那么 diff 算法将达不到最高效

- 在使用 v-for 时，我们可以为每个元素提供唯一的 key，使它可以跟踪每个节点，重新排序时可以复用现有元素

- key 可以使 Vue 更高效地渲染虚拟 DOM

- key 必须满足稳定性和唯一性





# 深入组件

## 组件注册

### 全局注册 Vue.component

```js
Vue.component("Component", Component)
```

### 局部注册 components

```js
components: {
  Component
}
```

## props

数组类型

```js
props: ["name", "age"]
```

对象类型

- type：数据类型

- default：默认值

- required：是否必须传值

- validator：自定义验证函数


```js
props: {
  name: String,
  age: {
    type: Number,
    default: 18
  }
}
```

传递方式

```vue
<!-- 批量传递 -->
<Component v-bind="person" />

<!-- 分别传递 -->
<Component :name="person.name" :age="person.age" />
```

## 自定义事件

### 监听事件 vm.$on

`vm.$on(event, listener)`

监听当前实例的自定义事件，回调函数会接收所有传入事件触发函数的额外参数

> v-on：用在普通元素上，可以监听原生事件；用在组件上，可以监听子组件触发的自定义事件
>
> vm.$on：监听实例自身的自定义事件

### 监听事件 vm.$once

`vm.$once(event, listener)`

监听当前实例的自定义事件，触发一次后移除监听器

### 触发事件 vm.$emit

`vm.$emit(event, [...args])`

触发当前实例的自定义事件，并将附加参数传递给监听器回调

```vue
<!-- Parent.vue -->
<Component @event-name="doSomething" />
```

```js
// Component.vue
this.$emit("event-name", this.message)
```

### 移除监听 vm.$off

`vm.$off([event], [listener])`

移除自定义事件监听器

- 如果没有提供参数，则移除所有的事件监听器

- 如果只提供了事件，则移除该事件所有的监听器

- 如果同时提供了事件与回调，则只移除这个回调的监听器

### 绑定原生事件 .native

将原生事件绑定到组件

> 绑定在组件上的事件默认为自定义事件

```vue
<Component @click.native="doSomething" />
```

## 事件总线 EventBus

> 兄弟组件之间传递数据

```js
// main.js
new Vue({
  beforeCreate() {
    Vue.prototype.$bus = this // 安装全局事件总线，this = vm
  }
})
```

```js
// A.vue
mounted() {
  this.$bus.$on("event-name", data => { // 监听事件
    console.log(data)
  })
},
beforeDestroy() {
  this.$bus.$off("event-name") // 移除事件
}
```

```js
// B.vue
this.$bus.$emit("event-name", this.msg) // 触发事件
```

## 发布订阅 Pubsub

> 兄弟组件之间传递数据

```js
// A.vue
import PubSub from "pubsub-js"

mounted() {
  this.pubsubId = PubSub.subscribe("message-name", (message /* 用 _ 占位 */, data) => {
    console.log(data)
  }) // 订阅消息
},
beforeDestroy() {
  PubSub.unsubscribe(this.pubsubId) // 取消订阅
}
```

```js
// B.vue
import PubSub from "pubsub-js"

PubSub.publish("message-name", this.msg) // 发布消息
```

## 快速访问

### 访问根组件 vm.$root

返回根组件实例

### 访问父组件 vm.$parent

返回父组件实例

### 访问子组件 vm.$children

返回子组件实例（数组）

> $children 不保证顺序，也不是响应式的，需要使用 v-for 来遍历子组件

### 访问子组件 vm.$refs

为普通 DOM 元素注册一个 ref 属性，返回这个 DOM 元素

为子组件注册一个 ref 属性，返回这个子组件实例（数组）

> $refs 在组件渲染完成之后生效，并且不是响应式的，所以应该避免使用它在模板中做数据绑定

## 插槽

### 默认插槽 \<slot>

在子组件中使用 \<slot> 定义插槽

在父组件中向子组件标签内插入 HTML，当组件渲染时，\<slot> 将会被替换为子组件标签内的内容

> 可以在 \<slot> 标签内设置默认内容，当子组件标签中没有插入内容时，\<slot> 会被替换为默认内容

```vue
<template>
  <div>
    <h3>{{ title }}</h3>
    <slot><h2>default</h2></slot>
  </div>
</template>

<script>
  export default {
    props: ["title"]
  }
</script>
```

```vue
<template>
  <div>
    <Category/>
    
    <Category title="音乐">
      <ul>
        <li v-for="(item, index) in music" :key="index">{{ item }}</li>
      </ul>
    </Category>
  </div>
</template>

<script>
  export default {
    data() {
      return {
        music: ["海阔天空", "光辉岁月", "灰色轨迹", "真的爱你"]
      }
    }
  }
</script>
```

### 具名插槽 v-slot

在 \<slot> 中添加 [name attribute]

> 未注册 [name attribute] 的 \<slot> 为默认插槽，name 默认为 "default"

在父组件中给指定元素添加 [slot attribute]，替换对应 [name attribute] 的 \<slot>

> 当多个元素替换同一个插槽时，用 \<template> 包裹这些元素并添加 v-slot，最终的渲染结果不包含 \<template>
>
> 任何没有被包裹在带有 v-slot 的 \<template> 中的内容都会被视为默认插槽的内容

> v-slot 只能用于 \<template>

```vue
<template>
  <div>
    <h3>{{ title }}</h3>
    <slot name="center"></slot>
    <slot name="footer"></slot>
  </div>
</template>

<script>
  export default {
    props: ["title"]
  }
</script>
```

```vue
<template>
  <div>
    <Category title="音乐">
      <ul slot="center">
        <li v-for="(item, index) in music" :key="index">{{ item }}</li>
      </ul>
      <template v-slot:footer>
        <a href="">热门</a>
        <a href="">推荐</a>
        <h4>欢迎听音乐</h4>
      </template>
    </Category>
  </div>
</template>

<script>
  export default {
    data() {
      return {
        music: ["海阔天空", "光辉岁月", "灰色轨迹", "真的爱你"]
      }
    }
  }
</script>
```

### 作用域插槽 v-slot

> 让插槽内容访问子组件的数据

在 \<slot> 上动态绑定 attribute，被称为插槽 prop，`<slot :attribute="data">`

在父级作用域中使用带值的 v-slot 来定义插槽 prop 的名字，`<template v-slot="slotProps">`

> 结合具名插槽使用，`<template v-slot:[name attribute]="slotProps">`

```vue
<template>
  <div>
    <h3>{{ title }}</h3>
    <slot :music="music">
      <ul>
        <li v-for="(item, index) in music" :key="index">{{ item }}</li>
      </ul>
    </slot>
  </div>
</template>

<script>
  export default {
    props: ["title"],
    data() {
      return {
        music: ["海阔天空", "光辉岁月", "灰色轨迹", "真的爱你"]
      }
    }
  }
</script>
```

```vue
<template>
  <div>
    <Category title="音乐">
      <template v-slot="slotProps">
        <span>{{ slotProps.music.join(" - ") }}</span>
      </template>
    </Category>
    <Category title="音乐">
      <template v-slot="{music}">
        <!-- 解构赋值 -->
        <span>{{ music.join(" * ") }}</span>
      </template>
    </Category>
  </div>
</template>
```





# 过滤器

## 全局注册 Vue.filter

```js
Vue.filter("capitalize", value => value.toUpperCase())
```

## 局部注册 filters

> 当全局过滤器和局部过滤器命名冲突时，优先使用局部过滤器

```js
filters: {
  capitalize(value) {
    return value.toUpperCase
  }
}
```

## 基本使用

过滤器用于插值语法和 v-bind，可以处理一些常见的文本格式化

- 管道符 "|" 左边的数据将作为过滤器的第一个参数

- 过滤器函数的参数 "arg" 将作为过滤器的第二个参数

- capitalize 的返回值将作为参数传递给 other 函数

```vue
<!-- 插值语法 -->
{{ message | capitalize }}
{{ message | capitalize(arg) }}
{{ message | capitalize | other }}

<!-- v-bind -->
<div :id="message | capitalize"></div>
```





# 自定义指令

## 全局注册 Vue.directive

```vue
<p v-red></p>
<p v-color="'red'"></p>
```

```js
Vue.directive("red", el => { /* 默认为 bind 钩子函数 */
  el.style.backgroundColor = "red"
})

Vue.directive("color", (el, binding) => {
  el.style.backgroundColor = binding.value
})
```

## 局部注册 directives

```js
directives: {
  red(el) {
    el.style.backgroundColor = "red"
  }
}
```

## 钩子函数

```js
Vue.directive("color", {
  bind(el, binding) {
    // 只调用一次, 指令第一次绑定到元素时调用, 在这里可以进行一次性的初始化设置
  },
  inserted(el, binding) {
    // 被绑定元素插入父节点时调用 (仅保证父节点存在, 但不一定已被插入文档中)
  },
  update(el, binding) {
    // 所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前
  },
  componentUpdated(el, binding) {
    // 指令所在组件的 VNode 及其子 VNode 全部更新后调用
  },
  unbind(el, binding) {
    // 只调用一次, 指令与元素解绑时调用
  }
})
```





# 插件

## 安装插件

- 参数是对象，需要提供 install 方法，当插件被使用时，默认调用 install 方法

- 参数是函数，该函数会作为 install 方法被调用

```js
Vue.use(MyPlugin)
```

## 开发插件

需要暴露一个 install 方法

- 第一个参数：Vue 构造器

- 第二个参数：一个可选的配置对象

```js
MyPlugin.install = function(Vue, options) {
  // 全局注册自定义指令
  Vue.directive("color", (el, binding) => {
    el.style.background = "red"
  })
  
  // 全局注册过滤器
  Vue.filter("capitalize", value => {
    return value.toUpperCase()
  })
  
  // 添加实例方法
  Vue.prototype.$myMethod = () => {
    console.log("hello world")
  }
}
```





# 混入

> 配置多个组件的共用选项

## 全局混入 Vue.mixin

> 影响注册之后创建的每个 Vue 实例

```js
import { mixin } from "../mixin.js"

Vue.mixin(mixin)

new Vue()
```

## 局部混入 mixins

> 当组件和混入对象含有同名数据时，以组件数据优先

```js
import { mixin } from "../mixin.js"

export default {
  mixins: [mixin]
}
```





# 渲染函数 & JSX

## render

- **类型**：`(createElement: () => VNode) => VNode`

- **详细**：

  字符串模板的代替方案，允许你发挥 JavaScript 最大的编程能力。该渲染函数接收一个 `createElement` 方法作为第一个参数用来创建 `VNode`

  如果组件是一个函数组件，渲染函数还会接收一个额外的 `context` 参数，为没有实例的函数组件提供上下文信息

  > Vue 选项中的 `render` 函数若存在，则 Vue 构造函数不会从 `template` 选项或通过 `el` 选项指定的挂载元素中提取出的 HTML 模板编译渲染函数

## renderError

- **类型**：`(createElement: () => VNode, error: Error) => VNode`

- **详细**：

  **只在开发者环境下工作**

  当 `render` 函数遭遇错误时，提供另外一种渲染输出。其错误将会作为第二个参数传递到 `renderError`。这个功能配合 hot-reload 非常实用

- **示例**：

  ```
  new Vue({
    render (h) {
      throw new Error("oops")
    },
    renderError (h, err) {
      return h("pre", { style: { color: "red" }}, err.stack)
    }
  }).$mount("#app")
  ```





# 过渡动画

## 概述

Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。包括以下工具：

- 在 CSS 过渡和动画中自动应用 class

- 可以配合使用第三方 CSS 动画库，如 Animate.css

- 在过渡钩子函数中使用 JavaScript 直接操作 DOM

- 可以配合使用第三方 JavaScript 动画库，如 Velocity.js

## 单元素/组件的过渡

Vue 提供了 `transition` 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡

- 条件渲染 (使用 `v-if`)

- 条件展示 (使用 `v-show`)

- 动态组件

- 组件根节点

这里是一个典型的例子：

```html
<div id="demo">
  <button v-on:click="show = !show">
    Toggle
  </button>
  <transition name="fade">
    <p v-if="show">hello</p>
  </transition>
</div>
```

```js
new Vue({
  el: "#demo",
  data: {
    show: true
  }
})
```

```css
.fade-enter-active, .fade-leave-active {
  transition: opacity .5s;
}
.fade-enter, .fade-leave-to /* .fade-leave-active below version 2.1.8 */ {
  opacity: 0;
}
```

当插入或删除包含在 `transition` 组件中的元素时，Vue 将会做以下处理：

1. 自动嗅探目标元素是否应用了 CSS 过渡或动画，如果是，在恰当的时机添加/删除 CSS 类名。

2. 如果过渡组件提供了 JavaScript 钩子函数，这些钩子函数将在恰当的时机被调用。

3. 如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作 (插入/删除) 在下一帧中立即执行。(注意：此指浏览器逐帧动画机制，和 Vue 的 `nextTick` 概念不同)

### 过渡的类名

在进入/离开的过渡中，会有 6 个 class 切换。

1. `v-enter`：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。

2. `v-enter-active`：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。

3. `v-enter-to`：**2.1.8 版及以上**定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 `v-enter` 被移除)，在过渡/动画完成之后移除。

4. `v-leave`：定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。

5. `v-leave-active`：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。

6. `v-leave-to`：**2.1.8 版及以上**定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 `v-leave` 被删除)，在过渡/动画完成之后移除。

![Transition Diagram](https://cn.vuejs.org/images/transition.png)

对于这些在过渡中切换的类名来说，如果你使用一个没有名字的 `<transition>`，则 `v-` 是这些类名的默认前缀。如果你使用了 `<transition name="my-transition">`，那么 `v-enter` 会替换为 `my-transition-enter`。

`v-enter-active` 和 `v-leave-active` 可以控制进入/离开过渡的不同的缓和曲线，在下面章节会有个示例说明

### CSS 过渡

常用的过渡都是使用 CSS 过渡。

下面是一个简单例子：

```html
<div id="example-1">
  <button @click="show = !show">
    Toggle render
  </button>
  <transition name="slide-fade">
    <p v-if="show">hello</p>
  </transition>
</div>
```

```js
new Vue({
  el: "#example-1",
  data: {
    show: true
  }
})
```

```css
/* 可以设置不同的进入和离开动画 */
/* 设置持续时间和动画函数 */
.slide-fade-enter-active {
  transition: all .3s ease;
}
.slide-fade-leave-active {
  transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);
}
.slide-fade-enter, .slide-fade-leave-to
/* .slide-fade-leave-active for below version 2.1.8 */ {
  transform: translateX(10px);
  opacity: 0;
}
```

### CSS 动画

CSS 动画用法同 CSS 过渡，区别是在动画中 `v-enter` 类名在节点插入 DOM 后不会立即删除，而是在 `animationend` 事件触发时删除。

示例：(省略了兼容性前缀)

```html
<div id="example-2">
  <button @click="show = !show">Toggle show</button>
  <transition name="bounce">
    <p v-if="show">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris facilisis enim libero, at lacinia diam fermentum id. Pellentesque habitant morbi tristique senectus et netus.</p>
  </transition>
</div>
```

```js
new Vue({
  el: "#example-2",
  data: {
    show: true
  }
})
```

```css
.bounce-enter-active {
  animation: bounce-in .5s;
}
.bounce-leave-active {
  animation: bounce-in .5s reverse;
}
@keyframes bounce-in {
  0% {
    transform: scale(0);
  }
  50% {
    transform: scale(1.5);
  }
  100% {
    transform: scale(1);
  }
}
```

### 自定义过渡的类名

我们可以通过以下 attribute 来自定义过渡类名：

- `enter-class`

- `enter-active-class`

- `enter-to-class` (2.1.8+)

- `leave-class`

- `leave-active-class`

- `leave-to-class` (2.1.8+)

他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 Animate.css 结合使用十分有用。

示例：

```
<link href="https://cdn.jsdelivr.net/npm/animate.css@3.5.1" rel="stylesheet" type="text/css">

<div id="example-3">
  <button @click="show = !show">
    Toggle render
  </button>
  <transition
    name="custom-classes-transition"
    enter-active-class="animated tada"
    leave-active-class="animated bounceOutRight"
  >
    <p v-if="show">hello</p>
  </transition>
</div>
```

```js
new Vue({
  el: "#example-3",
  data: {
    show: true
  }
})
```

### 同时使用过渡和动画

Vue 为了知道过渡的完成，必须设置相应的事件监听器。它可以是 `transitionend` 或 `animationend`，这取决于给元素应用的 CSS 规则。如果你使用其中任何一种，Vue 能自动识别类型并设置监听。

但是，在一些场景中，你需要给同一个元素同时设置两种过渡动效，比如 `animation` 很快的被触发并完成了，而 `transition` 效果还没结束。在这种情况中，你就需要使用 [type attribute] 并设置 `animation` 或 `transition` 来明确声明你需要 Vue 监听的类型。

### 显性的过渡持续时间

> 2.2.0 新增

在很多情况下，Vue 可以自动得出过渡效果的完成时机。默认情况下，Vue 会等待其在过渡效果的根元素的第一个 `transitionend` 或 `animationend` 事件。然而也可以不这样设定——比如，我们可以拥有一个精心编排的一系列过渡效果，其中一些嵌套的内部元素相比于过渡效果的根元素有延迟的或更长的过渡效果。

在这种情况下你可以用 `<transition>` 组件上的 `duration` prop 定制一个显性的过渡持续时间 (以毫秒计)：

```html
<transition :duration="1000">...</transition>
```

你也可以定制进入和移出的持续时间：

```html
<transition :duration="{ enter: 500, leave: 800 }">...</transition>
```

### JavaScript 钩子

可以在 attribute 中声明 JavaScript 钩子

```html
<transition
  v-on:before-enter="beforeEnter"
  v-on:enter="enter"
  v-on:after-enter="afterEnter"
  v-on:enter-cancelled="enterCancelled"

  v-on:before-leave="beforeLeave"
  v-on:leave="leave"
  v-on:after-leave="afterLeave"
  v-on:leave-cancelled="leaveCancelled"
>
  <!-- ... -->
</transition>
```

```js
// ...
methods: {
  // --------
  // 进入中
  // --------

  beforeEnter: function(el) {
    // ...
  },
  // 当与 CSS 结合使用时
  // 回调函数 done 是可选的
  enter: function(el, done) {
    // ...
    done()
  },
  afterEnter: function(el) {
    // ...
  },
  enterCancelled: function(el) {
    // ...
  },

  // --------
  // 离开时
  // --------

  beforeLeave: function(el) {
    // ...
  },
  // 当与 CSS 结合使用时
  // 回调函数 done 是可选的
  leave: function(el, done) {
    // ...
    done()
  },
  afterLeave: function(el) {
    // ...
  },
  // leaveCancelled 只用于 v-show 中
  leaveCancelled: function(el) {
    // ...
  }
}
```

这些钩子函数可以结合 CSS `transitions/animations` 使用，也可以单独使用。

> 当只用 JavaScript 过渡的时候，**在 `enter` 和 `leave` 中必须使用 `done` 进行回调**。否则，它们将被同步调用，过渡会立即完成。

> 推荐对于仅使用 JavaScript 过渡的元素添加 `v-bind:css="false"`，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。

一个使用 Velocity.js 的简单例子：

```html
<!--
  Velocity 和 jQuery.animate 的工作方式类似，也是用来实现 JavaScript 动画的一个很棒的选择
-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js"></script>

<div id="example-4">
  <button @click="show = !show">
    Toggle
  </button>
  <transition
    v-on:before-enter="beforeEnter"
    v-on:enter="enter"
    v-on:leave="leave"
    v-bind:css="false"
  >
    <p v-if="show">
      Demo
    </p>
  </transition>
</div>
```

```js
new Vue({
  el: "#example-4",
  data: {
    show: false
  },
  methods: {
    beforeEnter: function(el) {
      el.style.opacity = 0
      el.style.transformOrigin = "left"
    },
    enter: function(el, done) {
      Velocity(el, { opacity: 1, fontSize: "1.4em" }, { duration: 300 })
      Velocity(el, { fontSize: "1em" }, { complete: done })
    },
    leave: function(el, done) {
      Velocity(el, { translateX: "15px", rotateZ: "50deg" }, { duration: 600 })
      Velocity(el, { rotateZ: "100deg" }, { loop: 2 })
      Velocity(el, {
        rotateZ: "45deg",
        translateY: "30px",
        translateX: "30px",
        opacity: 0
      }, { complete: done })
    }
  }
})
```

## 初始渲染的过渡

可以通过 [appear attribute] 设置节点在初始渲染的过渡

```html
<transition appear>
  <!-- ... -->
</transition>
```

这里默认和进入/离开过渡一样，同样也可以自定义 CSS 类名。

```html
<transition
  appear
  appear-class="custom-appear-class"
  appear-to-class="custom-appear-to-class" (2.1.8+)
  appear-active-class="custom-appear-active-class"
>
  <!-- ... -->
</transition>
```

自定义 JavaScript 钩子：

```html
<transition
  appear
  v-on:before-appear="customBeforeAppearHook"
  v-on:appear="customAppearHook"
  v-on:after-appear="customAfterAppearHook"
  v-on:appear-cancelled="customAppearCancelledHook"
>
  <!-- ... -->
</transition>
```

在上面的例子中，无论是 `appear` attribute 还是 `v-on:appear` 钩子都会生成初始渲染过渡。

## 多个元素的过渡

我们之后讨论多个组件的过渡，对于原生标签可以使用 `v-if`/`v-else`。最常见的多标签过渡是一个列表和描述这个列表为空消息的元素：

```html
<transition>
  <table v-if="items.length > 0">
    <!-- ... -->
  </table>
  <p v-else>Sorry, no items found.</p>
</transition>
```

可以这样使用，但是有一点需要注意：

> 当有**相同标签名**的元素切换时，需要通过 `key` attribute 设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。即使在技术上没有必要，**给在 `` 组件中的多个元素设置 key 是一个更好的实践。**

示例：

```html
<transition>
  <button v-if="isEditing" key="save">
    Save
  </button>
  <button v-else key="edit">
    Edit
  </button>
</transition>
```

在一些场景中，也可以通过给同一个元素的 `key` attribute 设置不同的状态来代替 `v-if` 和 `v-else`，上面的例子可以重写为：

```html
<transition>
  <button v-bind:key="isEditing">
    {{ isEditing ? "Save" : "Edit" }}
  </button>
</transition>
```

使用多个 `v-if` 的多个元素的过渡可以重写为绑定了动态 property 的单个元素过渡。例如：

```html
<transition>
  <button v-if="docState === 'saved'" key="saved">
    Edit
  </button>
  <button v-if="docState === 'edited'" key="edited">
    Save
  </button>
  <button v-if="docState === 'editing'" key="editing">
    Cancel
  </button>
</transition>
```

可以重写为：

```html
<transition>
  <button v-bind:key="docState">
    {{ buttonMessage }}
  </button>
</transition>
```

```js
// ...
computed: {
  buttonMessage: function() {
    switch (this.docState) {
      case "saved": return "Edit"
      case "edited": return "Save"
      case "editing": return "Cancel"
    }
  }
}
```

### 过渡模式

这里还有一个问题，试着点击下面的按钮：

在“on”按钮和“off”按钮的过渡中，两个按钮都被重绘了，一个离开过渡的时候另一个开始进入过渡。这是 `<transition>` 的默认行为 - 进入和离开同时发生。

在元素绝对定位在彼此之上的时候运行正常：

然后，我们加上 translate 让它们运动像滑动过渡：

同时生效的进入和离开的过渡不能满足所有要求，所以 Vue 提供了**过渡模式**

- `in-out`：新元素先进行过渡，完成之后当前元素过渡离开。

- `out-in`：当前元素先进行过渡，完成之后新元素过渡进入。

用 `out-in` 重写之前的开关按钮过渡：

```html
<transition name="fade" mode="out-in">
  <!-- ... the buttons ... -->
</transition>
```

只用添加一个简单的 attribute，就解决了之前的过渡问题而无需任何额外的代码。

`in-out` 模式不是经常用到，但对于一些稍微不同的过渡效果还是有用的。将之前滑动淡出的例子结合：

## 多个组件的过渡

多个组件的过渡简单很多 - 我们不需要使用 `key` attribute。相反，我们只需要使用动态组件：

```html
<transition name="component-fade" mode="out-in">
  <component v-bind:is="view"></component>
</transition>
```

```js
new Vue({
  el: "#transition-components-demo",
  data: {
    view: "v-a"
  },
  components: {
    "v-a": {
      template: "<div>Component A</div>"
    },
    "v-b": {
      template: "<div>Component B</div>"
    }
  }
})
```

```css
.component-fade-enter-active, .component-fade-leave-active {
  transition: opacity .3s ease;
}
.component-fade-enter, .component-fade-leave-to
/* .component-fade-leave-active for below version 2.1.8 */ {
  opacity: 0;
}
```

## 列表过渡

目前为止，关于过渡我们已经讲到：

- 单个节点

- 同一时间渲染多个节点中的一个

那么怎么同时渲染整个列表，比如使用 `v-for`？在这种场景中，使用 `<transition-group>` 组件。在我们深入例子之前，先了解关于这个组件的几个特点：

- 不同于 `<transition>`，它会以一个真实元素呈现：默认为一个 `<span>`。你也可以通过 `tag` attribute 更换为其他元素。

- 过渡模式不可用，因为我们不再相互切换特有的元素。

- 内部元素**总是需要**提供唯一的 `key` attribute 值。

- CSS 过渡的类将会应用在内部的元素中，而不是这个组/容器本身。

### 列表的进入/离开过渡

现在让我们由一个简单的例子深入，进入和离开的过渡使用之前一样的 CSS 类名。

```html
<div id="list-demo" class="demo">
  <button v-on:click="add">Add</button>
  <button v-on:click="remove">Remove</button>
  <transition-group name="list" tag="p">
    <span v-for="item in items" v-bind:key="item" class="list-item">
      {{ item }}
    </span>
  </transition-group>
</div>
```

```js
new Vue({
  el: "#list-demo",
  data: {
    items: [1,2,3,4,5,6,7,8,9],
    nextNum: 10
  },
  methods: {
    randomIndex: function() {
      return Math.floor(Math.random() * this.items.length)
    },
    add: function() {
      this.items.splice(this.randomIndex(), 0, this.nextNum++)
    },
    remove: function() {
      this.items.splice(this.randomIndex(), 1)
    },
  }
})
```

```css
.list-item {
  display: inline-block;
  margin-right: 10px;
}
.list-enter-active, .list-leave-active {
  transition: all 1s;
}
.list-enter, .list-leave-to
/* .list-leave-active for below version 2.1.8 */ {
  opacity: 0;
  transform: translateY(30px);
}
```

这个例子有个问题，当添加和移除元素的时候，周围的元素会瞬间移动到他们的新布局的位置，而不是平滑的过渡，我们下面会解决这个问题。

### 列表的排序过渡

`<transition-group>` 组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的 **`v-move` class**，它会在元素的改变定位的过程中应用。像之前的类名一样，可以通过 `name` attribute 来自定义前缀，也可以通过 `move-class` attribute 手动设置。

`v-move` 对于设置过渡的切换时机和过渡曲线非常有用，你会看到如下的例子：

```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js"></script>

<div id="flip-list-demo" class="demo">
  <button v-on:click="shuffle">Shuffle</button>
  <transition-group name="flip-list" tag="ul">
    <li v-for="item in items" v-bind:key="item">
      {{ item }}
    </li>
  </transition-group>
</div>
```

```js
new Vue({
  el: "#flip-list-demo",
  data: {
    items: [1,2,3,4,5,6,7,8,9]
  },
  methods: {
    shuffle: function() {
      this.items = _.shuffle(this.items)
    }
  }
})
```

```css
.flip-list-move {
  transition: transform 1s;
}
```

这个看起来很神奇，内部的实现，Vue 使用了一个叫 FLIP 简单的动画队列
使用 transforms 将元素从之前的位置平滑过渡新的位置。

我们将之前实现的例子和这个技术结合，使我们列表的一切变动都会有动画过渡。

```

<div id="list-complete-demo" class="demo">
  <button v-on:click="shuffle">Shuffle</button>
  <button v-on:click="add">Add</button>
  <button v-on:click="remove">Remove</button>
  <transition-group name="list-complete" tag="p">
    <span
      v-for="item in items"
      v-bind:key="item"
      class="list-complete-item"
    >
      {{ item }}
    </span>
  </transition-group>
</div>
```

```js
new Vue({
  el: "#list-complete-demo",
  data: {
    items: [1,2,3,4,5,6,7,8,9],
    nextNum: 10
  },
  methods: {
    randomIndex: function() {
      return Math.floor(Math.random() * this.items.length)
    },
    add: function() {
      this.items.splice(this.randomIndex(), 0, this.nextNum++)
    },
    remove: function() {
      this.items.splice(this.randomIndex(), 1)
    },
    shuffle: function() {
      this.items = _.shuffle(this.items)
    }
  }
})
```

```css
.list-complete-item {
  transition: all 1s;
  display: inline-block;
  margin-right: 10px;
}
.list-complete-enter, .list-complete-leave-to
/* .list-complete-leave-active for below version 2.1.8 */ {
  opacity: 0;
  transform: translateY(30px);
}
.list-complete-leave-active {
  position: absolute;
}
```

> 需要注意的是使用 FLIP 过渡的元素不能设置为 `display: inline` 。作为替代方案，可以设置为 `display: inline-block` 或者放置于 flex 中

FLIP 动画不仅可以实现单列过渡，多维网格也同样可以过渡：

### 列表的交错过渡

通过 data attribute 与 JavaScript 通信，就可以实现列表的交错过渡：

```
<script src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js"></script>

<div id="staggered-list-demo">
  <input v-model="query">
  <transition-group
    name="staggered-fade"
    tag="ul"
    v-bind:css="false"
    v-on:before-enter="beforeEnter"
    v-on:enter="enter"
    v-on:leave="leave"
  >
    <li
      v-for="(item, index) in computedList"
      v-bind:key="item.msg"
      v-bind:data-index="index"
    >{{ item.msg }}</li>
  </transition-group>
</div>
```

```js
new Vue({
  el: "#staggered-list-demo",
  data: {
    query: "",
    list: [
      { msg: "Bruce Lee" },
      { msg: "Jackie Chan" },
      { msg: "Chuck Norris" },
      { msg: "Jet Li" },
      { msg: "Kung Fury" }
    ]
  },
  computed: {
    computedList: function() {
      var vm = this
      return this.list.filter(function(item) {
        return item.msg.toLowerCase().indexOf(vm.query.toLowerCase()) !== -1
      })
    }
  },
  methods: {
    beforeEnter: function(el) {
      el.style.opacity = 0
      el.style.height = 0
    },
    enter: function(el, done) {
      var delay = el.dataset.index * 150
      setTimeout(function() {
        Velocity(
          el,
          { opacity: 1, height: "1.6em" },
          { complete: done }
        )
      }, delay)
    },
    leave: function(el, done) {
      var delay = el.dataset.index * 150
      setTimeout(function() {
        Velocity(
          el,
          { opacity: 0, height: 0 },
          { complete: done }
        )
      }, delay)
    }
  }
})
```

## 可复用的过渡

过渡可以通过 Vue 的组件系统实现复用。要创建一个可复用过渡组件，你需要做的就是将 `<transition>` 或者 `<transition-group>` 作为根组件，然后将任何子组件放置在其中就可以了。

使用 template 的简单例子：

```js
Vue.component("my-special-transition", {
  template: `\
    <transition\
      name="very-special-transition"\
      mode="out-in"\
      v-on:before-enter="beforeEnter"\
      v-on:after-enter="afterEnter"\
    >\
      <slot></slot>\
    </transition>\
  `,
  methods: {
    beforeEnter: function(el) {
      // ...
    },
    afterEnter: function(el) {
      // ...
    }
  }
})
```

函数式组件更适合完成这个任务：

```js
Vue.component("my-special-transition", {
  functional: true,
  render: function(createElement, context) {
    var data = {
      props: {
        name: "very-special-transition",
        mode: "out-in"
      },
      on: {
        beforeEnter: function(el) {
          // ...
        },
        afterEnter: function(el) {
          // ...
        }
      }
    }
    return createElement("transition", data, context.children)
  }
})
```

## 动态过渡

在 Vue 中即使是过渡也是数据驱动的！动态过渡最基本的例子是通过 `name` attribute 来绑定动态值。

```html
<transition v-bind:name="transitionName">
  <!-- ... -->
</transition>
```

当你想用 Vue 的过渡系统来定义的 CSS 过渡/动画在不同过渡间切换会非常有用。

所有过渡 attribute 都可以动态绑定，但我们不仅仅只有 attribute 可以利用，还可以通过事件钩子获取上下文中的所有数据，因为事件钩子都是方法。这意味着，根据组件的状态不同，你的 JavaScript 过渡会有不同的表现。

```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js"></script>

<div id="dynamic-fade-demo" class="demo">
  Fade In: <input type="range" v-model="fadeInDuration" min="0" v-bind:max="maxFadeDuration">
  Fade Out: <input type="range" v-model="fadeOutDuration" min="0" v-bind:max="maxFadeDuration">
  <transition
    v-bind:css="false"
    v-on:before-enter="beforeEnter"
    v-on:enter="enter"
    v-on:leave="leave"
  >
    <p v-if="show">hello</p>
  </transition>
  <button
    v-if="stop"
    v-on:click="stop = false; show = false"
  >Start animating</button>
  <button
    v-else
    v-on:click="stop = true"
  >Stop it!</button>
</div>
```

```js
new Vue({
  el: "#dynamic-fade-demo",
  data: {
    show: true,
    fadeInDuration: 1000,
    fadeOutDuration: 1000,
    maxFadeDuration: 1500,
    stop: true
  },
  mounted: function() {
    this.show = false
  },
  methods: {
    beforeEnter: function(el) {
      el.style.opacity = 0
    },
    enter: function(el, done) {
      var vm = this
      Velocity(el,
        { opacity: 1 },
        {
          duration: this.fadeInDuration,
          complete: function() {
            done()
            if (!vm.stop) vm.show = false
          }
        }
      )
    },
    leave: function(el, done) {
      var vm = this
      Velocity(el,
        { opacity: 0 },
        {
          duration: this.fadeOutDuration,
          complete: function() {
            done()
            vm.show = true
          }
        }
      )
    }
  }
})
```

最后，创建动态过渡的最终方案是组件通过接受 props 来动态修改之前的过渡。一句老话，唯一的限制是你的想象力。





# Vue Router

## 基本配置

```js
// main.js

import Vue from "vue"
import VueRouter from "vue-router"
import router from "./router"

Vue.use(VueRouter)
```

```js
// index.js

import VueRouter from "vue-router"
import Home from "../views/Home"
import User from "../views/User"

const router = new VueRouter({
  routes: [
    {
      path: "/home",
      component: Home
    },
    {
      path: "/user",
      component: User
    }
  ]
})
```

`<router-view>` 渲染处于活跃状态的路由组件

```vue
<router-link to="/home">Home</router-link>
<router-link to="/user">User</router-link>
<router-view/>
```

## 嵌套路由

> 以 "/" 开头的嵌套路径会被当作根路径，所以子路由的路径不加 "/"

```js
const router = new VueRouter({
  routes: [
    {
      path: "/home",
      component: () => import("../views/Home"),
      children: [
        {
          path: "news",
          component: () => import("../views/Home_News")
        }
      ]
    }
  ]
})
```

## 默认路由

```js
const router = new VueRouter({
  routes: [
    {
      path: "",
      redirect: "/home" // 默认首页
    },
    {
      path: "/home",
      component: () => import("../views/Home")
    },
    {
      path: "/about",
      component: () => import("../views/About")
    }
  ]
})
```

## 命名路由

```js
const router = new VueRouter({
  routes: [
    {
      path: "/user/:id",
      name: "user",
      component: () => import("../views/User")
    }
  ]
})
```

要链接到一个命名路由，可以给 router-link 的 to 属性传一个对象

```vue
<router-link :to="{ name: 'user', params: { id: 59 } }">User</router-link>
```

## 动态路由

### $route.params

"动态路径参数" 使用 `:` 标记。当匹配到一个路由时，参数值会被设置到 $route.params 中：

| 模式            | 匹配路径 | $route.params      |
| :-------------- | :------- | :----------------- |
| /user/:username | /user/ln | { username: "ln" } |
| /user/:userId   | /user/59 | { userId: 59 }     |

```js
const router = new VueRouter({
  routes: [
    {
      path: "/user/:username",
      component: () => import("../views/User")
    }
  ]
})
```

```vue
<!-- 字符串写法，username 被设置到 $router.params 中 -->
<router-link :to="`/user/${username}`">User</router-link>

<!-- 对象写法 -->
<router-link :to="{ name: 'user', params: { username } }">User</router-link>
```

```vue
<!-- 在组件内使用 -->
<div>{{ $route.params.username }}</div>
```

给 to 属性传入的参数中，如果提供了 path，则 params 会被忽略，我们需要提供路由的 name

```vue
<!-- 这里的 params 不生效 -->
<router-link :to="{ path: '/user', params: { username } }">User</router-link>

<!-- /user/:username -->
<router-link :to="{ name: 'user', params: { username } }">User</router-link>
```

### $route.query

如果 URL 中有查询参数，参数值会被设置到 $router.query 中：

```js
const router = new VueRouter({
  routes: [
    {
      path: "/profile",
      component: () => import("../views/Profile")
    }
  ]
})
```

```vue
<!-- 字符串写法，userId 被设置到 $router.query 中 -->
<router-link :to="`/user?userId=${userId}`">User</router-link>

<!-- 对象写法 -->
<router-link :to="{ path: '/user', query: { userId } }">User</router-link>
```

```vue
<!-- 在组件内使用 -->
<div>{{ $route.query.userId }}</div>
```

## 声明式导航

- to: 指定跳转的地址

- tag: 指定生成的标签，默认渲染成超链接标签

- replace: 不会留下 history 历史记录，不能点击后退键返回到上一个页面

- active-class: 当对应的路由匹配成功时，会自动给当前元素设置 `class="router-link-active"`

```vue
<router-link to="/home" tag="button" replace>Home</router-link>
```

## 编程式导航

### $router.push

| 声明式                      | 编程式                  |
| --------------------------- | ----------------------- |
| `<router-link :to="/home">` | `$router.push("/home")` |

该方法的参数可以是一个字符串路径，或者一个描述地址的对象：

```js
// 字符串
$router.push("home")

// 对象
$router.push({ path: "home" })

// 命名路由
$router.push({ name: "user", params: { userId: 59 }})

// 带查询参数，变成 /user?userId=59
$router.push({ path: "user", query: { userId: 59 }})

// 手写完整的查询参数
$router.push({ path: "/user?userId=59" })
```

### $router.replace

| 声明式                              | 编程式                     |
| ----------------------------------- | -------------------------- |
| `<router-link :to="/home" replace>` | `$router.replace("/home")` |

与 $router.push 唯一的不同就是，它不会向 history 添加新记录，而是替换掉当前的 history 记录

### $router.forward

```js
// 前进一步记录
$router.forward()
```

### $router.back

```js
// 后退一步记录
$router.back()
```

### $router.go

```js
// 等同于 $router.forward()
$router.go(1)

// 等同于 $router.back()
$router.go(-1)

// 前进 3 步记录
$router.go(3)
```

## 路由懒加载

```js
const router = new VueRouter({
  routes: [
    {
      path: "/home",
      component: () => import("../views/Home")
    },
    {
      path: "/about",
      component: () => import("../views/About")
    }
  ]
})
```

## 路由组件传参

### 布尔模式

将路由中所有 params 参数以 props 的形式传给 User 组件

> 只能传递 params 参数

```js
const router = new VueRouter({
  routes: [
    {
      path: "/user/:username",
      component: () => import("../views/User"),
      props: true
    }
  ]
})
```

### 对象模式

将对象中所有 `key: value` 以 props 的形式传给 User 组件

> 只能传递静态参数

```js
const router = new VueRouter({
  routes: [
    {
      path: "/user/:username",
      component: () => import("../views/User"),
      props: { a: 1, b: 2 }
    }
  ]
})
```

### 函数模式

将函数返回的对象中所有 `key: value` 以 props 的形式传给 User 组件

> 可以接收 $route

```vue
<router-link :to="'/user/' + username">User</router-link>
```

```js
const router = new VueRouter({
  routes: [
    {
      path: "/user/:username",
      component: () => import("../views/User"),
      props: $route => ({ username: $route.params.username })
    }
  ]
})
```

```vue
<!-- 在组件内使用 -->
<template>
  <div>{{ username }}</div>
</template>

<script>
  export default {
    props: ["username"] // 接收路由中的 props
  }
</script>
```

## 缓存路由 \<keep-alive>

默认地，路由组件会在进入时被创建，离开时被销毁

使用 `<keep-alive>`，路由组件在离开时不会被销毁，且当前状态会被缓存，例如输入框内容、滚动条位置等

- include: 匹配的路由组件会被缓存

- exclude: 匹配的路由组件不会被缓存

- 若没有设置 include 或 exclude，则所有路由组件会被缓存

```vue
<!-- 缓存一个路由组件 -->
<keep-alive include="User">
  <router-view/>
</keep-alive>

<!-- 缓存多个路由组件 -->
<keep-alive :include="['Home_News', 'Home_Message']">
  <router-view/>
</keep-alive>
```

## 路由的生命周期钩子

### actived

路由组件被激活时触发

```js
activated() {
  console.log("组件被激活")
}
```

### deactivated

的路由组件失活时触发

```js
deactivated() {
  console.log("组件失活")
}
```

## 导航守卫

监听路由跳转的过程

### 全局前置守卫 router.beforeEach

```js
// 全局前置守卫，路由跳转前调用
router.beforeEach((to, from, next) => {
  document.title = to.matched[0].meta.title
  next()
})
```

### 全局解析守卫 router.beforeResolve



### 全局后置钩子 router.afterEach

```js
// 全局后置钩子，路由跳转后调用
router.afterEach((to, from) => {
  console.log("已跳转到(" + to.matched[0].meta.title + ")")
})
```

### 路由独享守卫 beforeEnter

```js
const router = new VueRouter({
  routes: [
    {
      path: "/user",
      component: () => import("../views/User"),
      // 路由独享守卫，进入路由前调用
      beforeEnter: (to, from, next) => {
        console.log("(" + to.matched[0].meta.title + ")跳转中...   " + "[路由独享守卫]")
        next()
      }
    }
  ]
})
```

### 组件内的守卫 beforeRouteEnter



## 解决重复跳转同一个路由的报错

```js
const originalReplace = VueRouter.prototype.replace
VueRouter.prototype.replace = function replace(location, onResolve, onReject) {
  if (onResolve || onReject) {
      return originalReplace.call(this, location, onResolve, onReject)
  }
  return originalReplace.call(this, location).catch(err => err)
}
```





# Vuex

Vuex 是一个状态（数据）管理插件，对所有组件的共享状态进行集中式管理

> Vue components ==(dispatch)=> actions ==(commit)=> mutations
>
> Vue components ==(commit)=> mutations

## Vuex.Store 构造器选项

> Vuex.store 实例的根对象

```js
const store = new Vuex.Store(
  /* options */
  {
    state: {
      count: 1
    },
    actions: {
      fun(context, payload) {
        setTimeout(() => {
          context.commit("FUN", payload)
        }, 1000)
      }
    },
    mutations: {
      FUN(state, payload) {
        state.count += payload.n
      }
    },
    getters: {
      add(state, getters) {
        return state.count += 1
      }
    },
    modules: {
      moduleA,
      moduleB
    }
  }
)
```

### state

> 保存共享状态

```js
state: {
  count: 1
}
```

### actions

> 执行异步操作，通常用于发送网络请求和处理复杂的业务逻辑

处理函数接收 context 作为第一个参数，payload 作为第二个参数（可选）

```js
actions: {
  fun(context, payload) {
    setTimeout(() => {
      context.commit("FUN", payload)
    }, 1000)
  }
}
```

context 对象包含以下属性：

```js
{
  dispatch,   // 等同于 store.dispatch
  commit,     // 等同于 store.commit
  state,      // 等同于 store.state，若在模块中则为局部状态
  getters,    // 等同于 store.getters
  rootState,  // 等同于 store.state，只存在于模块中
  rootGetters // 等同于 store.getters，只存在于模块中
}
```

### mutations

> 同步更新 state 中的状态时，可以通过 vue devtools 跟踪状态变化

处理函数接收 state 作为第一个参数，payload 作为第二个参数（可选）

```js
mutations: {
  FUN(state, payload) {
    state.count += payload.n
  }
}
```

### getters

> 类计算属性，处理 state 中的状态

类计算属性接收 state 作为第一个参数，其他 getter 作为第二个参数（可选）

```js
getters: {
  add(state, getters) {
    return state.count += 1
  }
}
```

模块中的 getters 接收以下参数：

```js
{
  state,      // 如果在模块中定义则为模块的局部状态
  getters,    // 等同于 store.getters
  rootState,  // 等同于 store.state，只存在于模块中
  rootGetters // 所有 getters，只存在于模块中
}
```

### modules

> 将 store 分割成模块，每个模块都有自己的 state、mutations、actions、getters、modules

```js
modules: {
  moduleA,
  moduleB
}
```

每个模块包含以下属性：

```js
{
  namespaced,  // 开启命名空间
  state,
  actions: {
    fun() {} // -> dispatch("moduleA/fun")
  },
  mutations: {
    FUN() {} // -> commit("moduleA/FUN")
  },
  getters: {
    add() {} // -> getters["moduleA/add"]
  },
  modules
}
```

## State

### 访问 state

通过 $store.state 访问

```vue
<template>
  <div>
    {{ $store.state.count }}
  </div>
</template>
```

### mapState 映射计算属性

将 store 中的 state 映射到局部计算属性

```js
import { mapState } from "vuex"

export default {
  computed: {
    // mapState() 的返回值是对象，使用展开运算符将该对象中的所有 key: value 混入到外部对象中
    ...mapState({
      // 把 count 映射为 $store.state.count
      count: "count"
    })
  }
}
```

当 computed 与值同名，可以给 mapState 传入一个字符串数组

```js
computed: {
  ...mapState([
    "count"
  ])
}
```

## Action

### dispatch 分发 Action

```js
// 以载荷形式分发
store.dispatch(type: string, [payload: any])
store.dispatch("fun", {
  key: value
})
// 以对象形式分发
store.dispatch(action: Object)
store.dispatch({
  type: "fun",
  key: "value"
})
```

### mapActions 在组件中分发

在组件中使用 `this.$store.dispatch()` 分发 action

或使用 mapActions 辅助函数将组件中的 methods 映射为 store.dispatch 调用

```js
import { mapActions } from "vuex"

export default {
  methods: {
    ...mapActions([
      // 将 fun([payload]) 映射为 $store.dispatch("fun", [payload])
      "fun"
    ])
  }
}
```

## Mutation

### commit 提交 Mutation

```js
// 以载荷形式提交
store.commit(type: string, [payload: any])
store.commit("FUN", {
  key: value
})

// 以对象形式提交
store.commit(mutation: Object)
store.commit({
  type: "FUN",
  key: "value"
})
```

### mapMutations 在组件中提交

在组件中使用 `this.$store.commit()` 提交 mutation

或使用 mapMutations 辅助函数将组件中的 methods 映射为 store.commit 调用

```js
import { mapMutations } from "vuex"

export default {
  methods: {
    ...mapMutations([
      // 将 FUN([payload]) 映射为 $store.commit("FUN", [payload])
      "FUN"
    ])
  }
}
```

## Getter

Getter 接受 state 作为其第一个参数：

```js
const store = new Vuex.Store({
  state: {
    todos: [
      { id: 1, text: "...", done: true },
      { id: 2, text: "...", done: false }
    ]
  },
  getters: {
    doneTodos: state => {
      return state.todos.filter(todo => todo.done)
    }
  }
})
```

### 访问 getters

通过 $store.getters 访问

> 通过属性访问：作为响应式系统的一部分缓存
>
> 通过方法访问：每次都会进行调用，不会缓存结果

```js
state: {
  todos: [
    { id: 1, text: "...", done: true },
    { id: 2, text: "...", done: false }
  ]
},
getters: {
  doneTodos: state => {
    return state.todos.filter(todo => todo.done)
  },
    getTodoById: (state) => (id) => {
    return state.todos.find(todo => todo.id === id)
  }
}

// 通过属性访问
store.getters.doneTodos // -> [{ id: 1, text: "...", done: true }]

// 通过方法访问
store.getters.getTodoById(2) // -> { id: 2, text: "...", done: false }
```

### mapGetters 映射计算属性

将 store 中的 getter 映射到局部计算属性

```js
import { mapGetters } from "vuex"

export default {
  computed: {
    ...mapGetters({
      // 把 count 映射为 $store.getters.count
      count: "count"
    })
  }
}
```

当 computed 与值同名，可以给 mapGetters 传入一个字符串数组

```js
computed: {
...mapGetters([
    "count"
  ])
}
```

## Module

### 访问 state

```js
// 直接访问
this.$store.state.moduleA.count
this.$store.state.moduleB.count

// mapState 访问
...mapState("moduleA", ["count"])
...mapState("moduleB", ["count"])
```

### 访问 getters

```js
// 直接访问
this.$store.state.moduleA.countPlus
this.$store.state.moduleB.countPlus

// mapGetters 访问
...mapGetters("moduleA", ["add", "sub"])
...mapGetters("moduleB", ["add", "sub"])
```

### 调用 dispatch

```js
// 直接调用
this.$store.dispatch("moduleA/fun", payload)
this.$store.dispatch("moduleB/fun", payload)

// mapActions 调用
...mapActions("moduleA", ["fun"]) // -> this["moduleA/fun"]()
...mapActions("moduleB", ["fun"]) // -> this["moduleB/fun"]()
```

### 调用 commit

```js
// 直接调用
this.$store.commit("moduleA/FUN", payload)this.$store.commit("moduleB/FUN", payload)

// mapMutations 调用
...mapMutations("moduleA", ["FUN"])...mapMutations("moduleB", ["FUN"])
```
