# 面试

## 自我介绍

面试官好，我叫俞文健，上一家公司是在武汉和奇科技，从事了两年的前端开发工作，主要技术栈是 Vue2 Vue3。最近一个项目是一个物业管理系统，我主要负责基础数据管理、停车管理、安防管理、登录和权限管理这几个模块，同时还负责了通用组件和 hooks 的封装。

## 项目介绍

### 简单介绍

我最近做的是一个小区的智能管理项目，主要实现小区的安防管理和给住户提供一些便利。我主要负责的模块有基础数据管理、安防管理、停车管理、还有登录和权限管理这几个模块。

基础数据管理主要有住户信息，包括楼栋、单元、家庭成员，有物业信息，包括物业报修、通知公告、投诉建议，还有有生活缴费，包括物业管理费、停车费等。

停车管理就包括车辆登记、登记审核、停车费管理、车辆进出记录，按照车主的详细信息，包括车牌号，是私人车位还是月租，还要上传车位产权凭证、行驶证，来登记车辆信息。然后后台人员看到车辆详细信息，来审核通过或者驳回。

安防管理要配合一些硬件设施来完成。

### 二次封装请求

携带请求前缀；

设置请求拦截器，携带 token；

设置响应拦截器，处理请求结果：失败的回调中提示请求失败的原因；成功的回调中提示功能失败的原因或返回数据。

```js
import axios from "axios"
import { ElMessage } from "element-plus"
import { useUserInfoStore } from "@/stores/userInfo"


// 功能失败的错误原因
export const authErrMessage = {
  10031: "登录失效，请重新登录",
  10032: "您太久没登录，请重新登录",
  10033: "账户未绑定角色，请联系管理员绑定角色",
  10034: "该用户未注册，请联系管理员注册用户",
  10035: "code 无法获取对应第三方平台用户",
  10036: "该账户未关联员工，请联系管理员做关联",
  10037: "账号已无效",
  10038: "账号未找到"
}

// 请求失败的错误原因
export const networkErrMessage = {
  400: "错误的请求",
  401: "未授权，请重新登录",
  403: "拒绝访问",
  404: "未找到该资源",
  405: "请求方法未允许",
  408: "请求超时",
  500: "服务器端出错",
  502: "网络错误",
  503: "服务不可用",
  504: "网络超时",
  505: "http 版本不支持该请求"
}

const request = axios.create({
  // 携带请求前缀
  baseURL: import.meta.env.VITE_API_URL,
  timeout: 50000
})

request.interceptors.request.use(
  config => {
    // 携带 token
    config.headers["token"] = useUserInfoStore().token
    
    return config
  }
)

request.interceptors.response.use(
  response => {
    const { code, data, message } = response.data
    
    if (code !== 20000 && code !== 200) {
      const errorMessage = authErrMessage[code] || message || "Error"
      
      // 提示功能失败的原因
      ElMessage.error(errorMessage)
      
      if (code === 10031 || code === 10032) {
        // 清空用户信息
        useUserInfoStore().reset()
        
        // 去登录页
        window.location.href = "/"
      }
      
      return Promise.reject(errorMessage)
    }
    else {
      return data
    }
  },
  error => {
    if (error.response) {
      ElMessage.error(networkErrMessage[error.response.status])
    }
    else {
      if (error.message.indexOf("timeout") !== -1) {
        ElMessage.error("网络超时")
      }
      else if (error.message.indexOf("Network") !== -1) {
        ElMessage.error("网络连接错误")
      }
      else if (error.message.indexOf("canceled") !== -1) {
        ElMessage.error("请求取消了")
      }
      
      return Promise.reject(error)
    }
  }
)

export default request
```

### 取消重复请求

- 需求背景：

  用户可能会存在多次发送重复请求的情况，比如说有个按钮点击没做处理，用户一直点就会一直发请求，这个可以用防抖节流来优化。但是有的时候不太好做节流，比如说是别人封装的组件，不好去改他的代码，就要取消重复请求。

- 具体做法：

  在请求拦截器中，准备一个 Map 容器，用来保存正在发送的请求，键名为请求的字符串标识，键值为一个取消请求的方法。每次发送请求时都判断在这个容器中，是否有相同的请求正在发送，如果有的话就取消上一次的请求，并把它从容器中移除；如果没有的话就把当前请求和取消这个请求的方法添加到容器中。等请求发送完成，去响应拦截器中将这个请求从容器中移除，就可以再次发送相同请求了。

- 怎么判断两个请求相同？

  判断两个请求是否是同一个请求，就是判断它们的请求方式、请求地址、请求头、请求体、携带参数是否一致。

### 取消上一页请求

- 需求背景：

  如果用户在一个页面点了五次按钮，然后切换到另一个页面，那么就需要等待上一个页面的五次请求发送完成，才能在当前页面发送请求。这是因为浏览器在 HTTP/1.1 协议下，同一时间内在一个域名下最多只能发六个请求，所以如果一次性发送的请求超过六个，超出的请求就需要排队。这样不仅上一个页面的请求没有意义，还会使当前页面的请求发不出去，导致页面阻塞渲染。这时候就需要做一些处理，取消上一个页面的请求。

- 具体做法：

  在将当前请求和取消请求的方法添加到 Map 容器中的同时，添加当前页面的路径信息。也就是容器中存储的数据键名为请求的字符串标识，键值为一个对象，包括取消请求的方法和页面的路径信息。然后去路由全局前置守卫中遍历容器，如果存储的路径信息与要去的页面路径不相等，说明它们不是同一个页面的请求，就取消容器中的这个请求，并把它从容器中移除。

### 无感刷新

- 需求背景：

  因为项目中是用到了七天免登录的，但是如果只这么做的话，用户每隔七天就要去重新登录一次，这样体验就不是很好。所以使用无感刷新来优化用户的体验，用户只要在七天内登录了，就会一直有最新的 token，一直处于免登录状态。只有超过连续七天没登录，token 才会过期，用户才需要重新登录。

- 具体做法：

  后端会返回两个 token，一个是 Access token，有效期很短，比如半个小时，它是用来请求用户数据的；一个是 Refresh token，有效期较长，比如七天或者半个月，它是用来请求 Access token 的。我们请求数据时，是携带 Access token 发送的，如果发现 Access token 过期了，就需要携带 Refresh token 去请求，服务器会将最新的 Access token 和 Refresh token 都返回，然后携带新的 Access token 重新请求数据。这样就可以实现无感刷新的效果。还需要设置定时刷新，每隔一段时间，去请求一次 Access token，这样确保用户停留在页面的时候，双 token 一直存在。

### 权限管理



### 大数据渲染

- WebSocket：

  开启 WebSocket 实时接收数据。连接成功后还需要持续检测是否断线，如果断开连接，就会触发 close 事件，在 close 事件中进行重连。但是弱网、断网情况下，不会触发 close 事件，所以就需要使用心跳检测机制检测是否断线。

- 心跳检测：

  客户端每隔一分钟向服务器发送一个特定的信号，比如 ping；服务器要立即返回一个信号，比如 pong。客户端需要检测在规定时间内（5 秒）是否收到信号，如果客户端收到了信号，说明连接没问题，开始下一次心跳检测；如果没有收到信号，说明连接有问题，需要重连。

- 断线重连：

  设置最大重连次数，每隔一段时间重连一次，如果超过最大次数，就不重连了。

  ```js
  /* useSocket.ts */
  
  class Socket {
    HEART_CHECK_TIME = 1000 // 心跳检测间隔时间
    HEART_CHECK_END_TIME = 5000 // 心跳检测接收服务器信号时间
    success = false // 心跳检测是否成功
    
    RECONNECT_TIME = 30000 // 断线重连间隔时间
    MAX_RECONNECT_COUNT = 5 // 最大重连次数
    reconnectCount = 0 // 当前重连次数
    reconnectId: NodeJS.Timeout | undefined
    
    url: string
    ws: WebSocket
    
    callbacks: { (data: any): void }[] = []
    
    constructor(url: string) {
      this.url = url
      this.ws = this.initSocket()
    }
    
    initSocket() {
      // 创建一个 WebSocket 实例
      const ws = new WebSocket(this.url)
      
      // WebSocket 连接成功
      ws.onopen = () => {
        this.ws.addEventListener("message", this.onPong) // 监听 pong 信号
        this.keepAlive() // 心跳检测
        
        this.reconnectCount = 0 // 重置重连次数
      }
      
      // WebSocket 断开连接
      ws.onclose = () => {
        this.reconnect() // 开始重连
      }
      
      // WebSocket 连接失败
      ws.onerror = (error) => {
        console.log("error", error)
      }
      
      ws.addEventListener("message", ({ data }) => {
        if (data === "pong") return
        
        this.callbacks.forEach(cb => cb(JSON.parse(data)))
      })
      
      return ws
    }
    
    // 接收消息
    onMessage(cb: { (data: any): void }) {
      this.callbacks.push(cb)
    }
    
    // 删除消息
    removeMessage(cb?: { (data: any): void }) {
      if (!cb) {
        this.callbacks = []
        return
      }
      
      this.callbacks = this.callbacks.filter(callback => callback !== cb)
    }
    
    // 监听 pong 信号
    onPong = ({ data }: MessageEvent) => {
      if (data === "pong") {
        this.success = true
      }
    }
    
    // 心跳检测
    keepAlive() {
      setTimeout(() => {
        // 向服务器发送 ping 信号
        this.ws.send("ping")
        
        // 在 5s 内检测是否接收到 pong 信号
        setTimeout(() => {
          if (this.success) {
            this.success = false
            
            this.keepAlive() // 开始下一次心跳检测
          }
          else {
            this.ws.close() // 关闭 WebSocket
            
            this.reconnect() // 开始重连
          }
        }, this.HEART_CHECK_END_TIME)
      }, this.HEART_CHECK_TIME)
    }
    
    // 断线重连
    reconnect() {
      // 超过次数限制，就不重连了
      if (this.reconnectCount >= this.MAX_RECONNECT_COUNT) return
      
      clearTimeout(this.reconnectId)
      this.reconnectId = setTimeout(() => {
        this.reconnectCount++
        this.ws = this.initSocket()
      }, this.RECONNECT_TIME)
    }
  }
  
  export default function useSocket(url: string) {
    return new Socket(url)
  }
  ```

- 虚拟列表：

  假如有一万条数据需要处理，如果每条数据都生成一个元素，那么就会造成页面卡死。

  降采样策略：我们可以不用渲染全部数据，只渲染能看见的二十条数据，其他数据替换为一个空元素进行占位，这个空元素的大小与原本需要渲染的数据的大小相同。

  设置渲染数据范围：我们需要知道这二十条数据在总数据列表中的开始索引和结束索引，那么这个空元素的高度就是开始索引乘数据的高度。

  控制数据的变化：用平移来控制容器的滚动，每平移一条数据的高度，开始索引就加一，从而实现数据的滚动效果。

  ```vue
  <script setup lang="ts">
    import { ref, computed, onBeforeUnmount } from "vue"
    import useSocket from "./useSocket.ts"
    
    interface ItemType {
      id: string
      date: string
      address: string
      number: number
    }
    
    const virtualList = ref<ItemType[]>([])
    
    const startIndex = ref(0)
    const endIndex = ref(20)
    
    const realList = computed(() => virtualList.value.slice(startIndex.value, endIndex.value))
    
    const socket = useSocket("ws://localhost:8000")
    
    socket.onMessage((data: ItemType[]) => {
      virtualList.value = [...virtualList.value, ...data]
      
      start()
    })
    
    const top = ref(0)
    
    let timer: NodeJS.Timeout
    let isMouseEnter = false
    
    const start = () => {
      if (virtualList.value.length <= 23 || isMouseEnter) return
      
      clearInterval(timer)
      timer = setInterval(() => {
        top.value -= 0.6
        
        startIndex.value = Math.abs(Math.ceil(top.value / 30))
        endIndex.value = startIndex.value + 20
      }, 1000 / 60)
    }
    
    onBeforeUnmount(() => {
      clearInterval(timer)
    })
    
    const onEnter = () => {
      isMouseEnter = true
      clearInterval(timer)
    }
    
    const onLeave = () => {
      isMouseEnter = false
      start()
    }
  </script>
  
  <template>
    <div>
      <h3>需求人数</h3>
      
      <div class="container">
        <header class="row">
          <div>日期</div>
          <div>地址</div>
          <div>人数</div>
        </header>
        
        <main class="main" @mouseenter="onEnter" @mouseleave="onLeave">
          <div :style="{ transform: `translateY(${ top }px)` }">
            <div :style="{ height: startIndex * 30 + 'px' }"></div>
            
            <div class="row" v-for="{ id, date,address,number } in realList" :key="id">
              <div>{{ date }}</div>
              <div>{{ address }}</div>
              <div>{{ number }}</div>
            </div>
          </div>
        </main>
      </div>
    </div>
  </template>
  
  <style scoped>
    .container .main {
      overflow: hidden;
    }
    
    .container .main .row {
      height: 30px;
    }
  </style>
  ```

### 大屏适配

通过计算 scale 缩放系数完成适配。

当屏幕宽高比大于设计图宽高比，说明是宽屏，缩放系数为屏幕高度除以设计图高度；

当屏幕宽高比小于设计图宽高比，说明是竖屏，缩放系数为屏幕宽度除以设计图宽度。

```vue
<script setup lang="ts">
  import { ref, onMounted, onBeforeUnmount } from "vue"
  
  const scale = ref(1)
  
  const draftWidth = 1519
  const draftHeight = 747
  
  const resize = () => {
    const screenWidth = document.body.clientWidth
    const screenHeight = document.body.clientHeight
    
    if (screenWidth / screenHeight > draftWidth / draftHeight) {
      scale.value = screenHeight / draftHeight
    }
    else {
      scale.value = screenWidth / draftWidth
    }
  }
  
  onMounted(() => {
    resize()
    window.addEventListener("resize", resize)
  })
  
  onBeforeUnmount(() => {
    window.removeEventListener("resize", resize)
  })
</script>

<template>
  <div class="app">
    <div class="container" :style="{ transform: `scale(${ scale })` }"></div>
  </div>
</template>
```

### 封装的组件



### 封装的 hooks



### 介绍 VueUse



### 项目优化