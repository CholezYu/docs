---
title: 面试集锦
icon: markdown
date: 2024-04-22
---

## 事件循环

- 事件循环是浏览器用于调度异步任务的机制：

  - 浏览器主要的进程有：浏览器进程、网络进程、渲染进程。

  - 渲染进程中又包含了多个线程：GUI 渲染线程、JS 引擎线程、事件触发线程、计时线程、渲染主线程。

- 事件循环具体是什么？

  浏览器的渲染进程启动后，会开启一个渲染主线程，它会进入一个无限循环，每一次循环都会检查任务队列中是否有任务存在。如果有，就取出第一个任务执行，执行完进入下一次循环；如果没有，则进入休眠状态。其他线程可以随时向任务队列添加任务：比如说计时线程，计时器时间到了，往里面加任务；比如说交互线程，监听到了用户点击，往里面加任务。加任务的时候一定是把它加到任务队列的末尾，先来的先执行，后来的排队。在添加新任务时，如果主线程处于休眠状态，会将其唤醒，继续循环执行任务。这个过程叫做事件循环。

- 事件循环是实现异步的方式，那么异步又是什么？

  JS 运行在浏览器的渲染主线程中，而渲染主线程只有一个，所以 JS 是单线程执行的。这是为了保证页面渲染的可靠性和一致性，防止多个线程同时修改 DOM 引起的问题。而渲染主线程需要做很多工作，比如解析 HTML、解析 CSS、计算样式、布局、执行全局 JS 代码。而在代码执行的过程中，会遇到一些无法立即处理的任务，比如：计时器回调、网络请求完成后需要执行的任务、用户操作后需要执行的任务。如果使用同步的方式，让渲染主线程等待这些任务的执行，就会导致主线程长期处于阻塞状态，从而导致任务队列中很多其他任务无法被执行。这样一来，一方面会导致主线程白白地消耗时间，另一方面也会导致页面无法及时更新，给用户造成卡死现象。而渲染主线程承担着极其重要的工作，无论如何都不能阻塞，所以浏览器采用异步的方式来解决这个问题。当某些任务发生时，比如计时器、网络请求、事件监听，主线程会将任务交给其他线程去处理。当其他线程完成时，会将事先传递的回调函数包装成任务，加入到任务队列的末尾排队，等待主线程调度。在这种异步模式下，浏览器永不阻塞，从而最大程度地保证了单线程的流畅运行。

- JS 为什么会阻塞页面渲染？

  在浏览器中，GUI 线程负责解析 HTML、CSS 并进行页面的绘制，JS 引擎线程负责执行 JS 代码。由于 GUI 渲染和 JS 执行共享同一个渲染主线程，所以它们是互斥的。当 GUI 渲染线程准备渲染页面时，如果遇到需要执行 JS 的情况，会等待 JS 引擎线程执行完毕后再继续渲染。这期间，渲染主线程处于阻塞状态，页面渲染暂停。

- 任务队列的优先级：

  任务是没有优先级的，在任务队列中先进先出。但是任务队列是有优先级的。根据 W3C 最新解释：每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务属于不同的队列。在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。浏览器必须准备一个微队列，微队列中的任务优先所有其他任务执行。随着浏览器复杂度急剧提升，W3C 不再使用宏队列的说法。在目前谷歌浏览器的实现中，至少包含了：延时队列，用于存放计时器的回调任务；交互队列，用于存放用户操作后产生的任务；网络队列，用于存放网络请求完成后产生的任务；微队列，也称为 vip 队列，优先级最高。在延时队列、交互队列、网络队列中，交互队列的优先级更高，因为浏览器认为用户的交互更加重要。

- JS 中的计时器能精确计时吗？

  不能，因为计时器回调需要在任务队列中排队，而在它前面可能有其他任务正在排队，所以需要等待它前面的任务执行完，所以还应该算上它前面那些任务的执行时间。而且，按照 W3C 标准，浏览器实现计时器时，如果嵌套层级超过 5 层，会带有 4 毫秒的最少时间，如果计时时间少于 4 毫秒时，会带来偏差。我们用的计时器函数例如 setTimeout 和 setInterval 其实最终调用的是操作系统的函数，而操作系统的计时函数本身就有少量偏差，并且不同操作系统，它的实现不一样，Windows 和 Mac 就不一样，谷歌浏览器实际上是针对 Windows 和 Mac 都做了不同的实现，调的是不同的函数，所以 JS 的计时器就携带了这些偏差。

- 总结：

  单线程是异步产生的原因。事件循环是异步的实现方式。异步的实现可以解决主线程阻塞的问题，有了异步之后，线程永不阻塞。

## HTTP

- HTTP 是超文本传输协议，是浏览器与服务器通信的协议。

- 协议通信的内容称为报文。浏览器发送给服务器的报文称为请求报文，服务器返回给浏览器的报文称为响应报文。

- 请求报文：

  - 由请求首行、请求头、空行、请求体组成。

  - 请求首行包括请求方式、请求地址、协议版本。

  - 请求头有：

    `Accept`: 浏览器可以接收的数据类型

    `User-Agent`: 浏览器类型

    `Content-Type`: 请求体的数据类型

    `Referer`: 请求来源地址

    `Cookie`: 可以携带数据发送给服务器

  - 空行用于分隔请求头和请求体。

  - 请求体就是浏览器携带的数据。一般用于 Post 请求，Get 请求的请求体为空。

- 响应报文：

  - 由响应首行、响应头、空行、响应体组成。
  
  - 响应首行包括协议版本、响应状态码、状态码信息。
  
  - 响应头有：
  
    `Access-Control-Allow-Origin`: 允许跨域的地址
  
    `Content-Type`: 响应体的数据类型
  
    `Cache-Control`: 强制缓存字段
  
    `Etag / Last-Modifined`: 协商缓存字段
  
  - 空行用于分隔响应头和响应体。
  
  - 响应体就是服务器返回的数据。
  
- 响应状态码：

  - 1xx: 请求正在处理

  - 2xx: 请求处理成功

    200: 请求成功

  - 3xx: 请求重定向，需要进一步处理

    301: 永久重定向

    302: 临时重定向

    304: 重定向到浏览器缓存

  - 4xx: 客户端错误

    400: 请求出现语法错误

    401: 未认证、未授权

    403: 拒绝访问

    404: 找不到资源

    407: token 无效

  - 5xx: 服务器错误

    500: 服务器内部错误

    503: 服务器停机维护或已超载，无法处理请求


## Get 和 Post

- 根据规范：Get 用于查询数据；Post 用于添加数据。

- Get 将数据携带在 url 中发送请求；Post 将数据携带在请求体中发送请求。

- Get 携带数据大小有限，因为 url 有长度限制；Post 携带数据大小没有限制。

- Get 有缓存；Post 没有。

## 强制缓存和协商缓存

- 缓存是什么？

  强制缓存和协商缓存是浏览器的两种缓存策略。合理设置缓存可以减少不必要的网络传输，提高网页加载速度。

- 强制缓存：

  浏览器第一次发送请求时，服务器会将强制缓存字段 Cache-Control 或 Expires 携带响应头中，它们分别表示缓存的有效时间和绝对过期时间。告诉浏览器将该资源缓存在本地。浏览器再次请求该资源时，会先检查本地缓存是否有效。如果有效，浏览器直接从缓存中获取资源，而不会向服务器发送请求；如果无效，则进行协商缓存。

- 协商缓存：

  强制缓存失败后，浏览器会携带缓存标识向服务器发送请求，服务器根据缓存标识决定是否使用缓存。当浏览器第一次发送请求时，服务器将协商缓存字段 Etag 和 Last-Modified 携带在响应头返回，它们分别表示文件唯一标识和资源最后修改时间。当浏览器再次请求该资源时，会将 If-None-Match 字段和 If-Modified-Since 字段携带在请求头中，它们的值分别为上次获取资源时的 Etag 和 Last-Modified 值。服务器收到请求后，会将 If-None-Match 与文件唯一标识进行比较，如果相等，说明请求的是同一资源；再将 If-Modified-Since 与资源最后修改时间进行比较，如果时间一致，说明资源未修改，服务器响应 304 状态码，浏览器会直接从缓存获取资源；如果时间不一致，说明资源已修改，服务器会响应 200 状态码，并返回新的资源，并在响应头携带新的强制缓存和协商缓存字段。

- `Cache-Control: nocache;` 表示不进行强制缓存，强制向服务器发送请求，可能会命中协商缓存。

- `Cache-Control: no-store;` 禁止所有缓存。

## 在浏览器地址栏按下回车发生了什么

- 首先解析地址栏中的内容是否合法，如果不合法，就会使用搜索引擎搜索地址栏的内容。

- 然后判断是否进行强制缓存。

- 再进行 DNS 解析，将域名解析为 IP 地址。

  - 判断浏览器是否有 DNS 缓存；

  - 判断电脑是否有 DNS 缓存；

  - 判断路由器是否有 DNS 缓存；

  - 判断网络运营商是否有 DNS 缓存，这个是需要花钱买 DNS 解析服务的；

  - 去根域名服务器递归查询 DNS，最终返回 IP 地址。

- 再进行 TCP 三次握手，确保通信双方的收发能力正常。

  - 浏览器向服务器发送一个 SYN 请求数据包，确认浏览器的发送能力正常；

  - 服务器向浏览器发送 SYN 请求数据包和 ACK 应答数据包，确认服务器的收发能力正常；

  - 浏览器向服务器发送一个 ACK 应答数据包，确认浏览器的接收能力正常。

- 浏览器将数据以请求报文的形式发送给服务器。

- 服务器将数据以响应报文的形式返回给浏览器。

- 浏览器根据响应数据，解析并渲染页面：

  - 浏览器遇到 html，使用 html 解析器将 html 解析成 DOM 树；

  - 浏览器遇到 css，使用 css 解析器将 css 解析成 CSSOM 树；

  - DOM 树和 CSSOM 树结合生成 render 树；

  - 浏览器根据 render 树，进行布局和渲染；

  - 如果浏览器遇到 js 代码，渲染主线程会处于阻塞状态，页面暂停渲染，等待 JS 引擎线程解析 js 代码；

  - 如果 js 修改了 DOM 元素，则重新构建 DOM 树；

  - 如果 js 修改了样式，则重新构建 CSSOM 树；

  - DOM 树和 CSSOM 树重新结合生成 render 树；

  - 浏览器根据 render 树，重新布局和渲染，这个过程也叫作重绘重排；

  - 重绘不一定导致重排，但是重排一定会导致重绘；

  - 一般，元素的样式、尺寸、位置、布局的改变，或者元素的增加与删除，会引起重绘重排；

  - 我们可以使用平移代替偏移量，通过防抖节流控制事件的触发频率等方式，来减少重绘重排。

- 最后进行 TCP 四次挥手，彻底断开浏览器和服务器的连接。

  - 浏览器向服务器发送 FIN 数据包请求断开连接；

  - 服务器向浏览器发送 ACK 应答数据包表示收到并同意断开连接请求；

  - 服务器等待数据处理完毕，向浏览器发送 FIN 数据包请求断开连接；

  - 浏览器向服务器发送 ACK 应答数据包表示收到并同意断开连接请求。

## 取消重复请求

- 需求背景：

  用户可能会存在多次发送重复请求的情况，比如说有个按钮点击没做处理，用户一直点就会一直发请求，这个可以用防抖节流来优化。但是有的时候不太好做节流，比如说是别人封装的组件，不好去改他的代码，就要取消重复请求。

- 具体做法：

  在请求拦截器中，准备一个 Map 容器，用来保存正在发送的请求，键名为请求的字符串标识，键值为一个取消请求的方法。每次发送请求时都判断在这个容器中，是否有相同的请求正在发送，如果有的话就取消上一次的请求，并把它从容器中移除；如果没有的话就把当前请求和取消这个请求的方法添加到容器中。等请求发送完成，去响应拦截器中将这个请求从容器中移除，就可以再次发送相同请求了。

- 怎么判断两个请求相同？

  判断两个请求是否是同一个请求，就是判断它们的请求方式、请求地址、请求头、请求体、携带参数是否一致。

## 取消上一页请求

- 需求背景：

  如果用户在一个页面点了五次按钮，然后切换到另一个页面，那么就需要等待上一个页面的五次请求发送完成，才能在当前页面发送请求。这是因为浏览器在 HTTP/1.1 协议下，同一时间内在一个域名下最多只能发六个请求，所以如果一次性发送的请求超过六个，超出的请求就需要排队。这样不仅上一个页面的请求没有意义，还会使当前页面的请求发不出去，导致页面阻塞渲染。这时候就需要做一些处理，取消上一个页面的请求。

- 具体做法：

  在将当前请求和取消请求的方法添加到 Map 容器中的同时，添加当前页面的路径信息。也就是容器中存储的数据键名为请求的字符串标识，键值为一个对象，包括取消请求的方法和页面的路径信息。然后去路由全局前置守卫中遍历容器，如果存储的路径信息与要去的页面路径不相等，说明它们不是同一个页面的请求，就取消容器中的这个请求，并把它从容器中移除。

## 无感刷新

- 需求背景：

  因为项目中是用到了七天免登录的，但是如果只这么做的话，用户每隔七天就要去重新登录一次，这样体验就不是很好。所以使用无感刷新来优化用户的体验，用户只要在七天内登录了，就会一直有最新的 token，一直处于免登录状态。只有超过连续七天没登录，token 才会过期，用户才需要重新登录。

- 具体做法：

  后端会返回两个 token，一个是 Access token，有效期很短，比如半个小时，它是用来请求用户数据的；一个是 Refresh token，有效期较长，比如七天或者半个月，它是用来请求 Access token 的。我们请求数据时，是携带 Access token 发送的，如果发现 Access token 过期了，就需要携带 Refresh token 去请求，服务器会将最新的 Access token 和 Refresh token 都返回，然后携带新的 Access token 重新请求数据。这样就可以实现无感刷新的效果。还需要设置定时刷新，每隔一段时间，去请求一次 Access token，这样确保用户停留在页面的时候，双 token 一直存在。

## 大数据渲染

- WebSocket：

  开启 WebSocket 实时接收数据。连接成功后还需要持续检测是否断线，如果断开连接，就会触发 close 事件，在 close 事件中进行重连。但是弱网、断网情况下，不会触发 close 事件，所以就需要使用心跳检测机制检测是否断线。

- 心跳检测：

  客户端每隔一分钟向服务器发送一个特定的信号，比如 ping；服务器要立即返回一个信号，比如 pong。客户端需要检测在规定时间内（5 秒）是否收到信号，如果客户端收到了信号，说明连接没问题，开始下一次心跳检测；如果没有收到信号，说明连接有问题，需要重连。

- 断线重连：

  设置最大重连次数，每隔一段时间重连一次，如果超过最大次数，就不重连了。

  ```js
  /* useSocket.ts */
  
  class Socket {
    HEART_CHECK_TIME = 1000 // 心跳检测间隔时间
    HEART_CHECK_END_TIME = 5000 // 心跳检测接收服务器信号时间
    success = false // 心跳检测是否成功
    
    RECONNECT_TIME = 30000 // 断线重连间隔时间
    MAX_RECONNECT_COUNT = 5 // 最大重连次数
    reconnectCount = 0 // 当前重连次数
    reconnectId: NodeJS.Timeout | undefined
    
    url: string
    ws: WebSocket
    
    callbacks: { (data: any): void }[] = []
    
    constructor(url: string) {
      this.url = url
      this.ws = this.initSocket()
    }
    
    initSocket() {
      // 创建一个 WebSocket 实例
      const ws = new WebSocket(this.url)
      
      // WebSocket 连接成功
      ws.onopen = () => {
        this.ws.addEventListener("message", this.onPong) // 监听 pong 信号
        this.keepAlive() // 心跳检测
        
        this.reconnectCount = 0 // 重置重连次数
      }
      
      // WebSocket 断开连接
      ws.onclose = () => {
        this.reconnect() // 开始重连
      }
      
      // WebSocket 连接失败
      ws.onerror = (error) => {
        console.log("error", error)
      }
      
      ws.addEventListener("message", ({ data }) => {
        if (data === "pong") return
        
        this.callbacks.forEach(cb => cb(JSON.parse(data)))
      })
      
      return ws
    }
    
    // 接收消息
    onMessage(cb: { (data: any): void }) {
      this.callbacks.push(cb)
    }
    
    // 删除消息
    removeMessage(cb?: { (data: any): void }) {
      if (!cb) {
        this.callbacks = []
        return
      }
      
      this.callbacks = this.callbacks.filter(callback => callback !== cb)
    }
    
    // 监听 pong 信号
    onPong = ({ data }: MessageEvent) => {
      if (data === "pong") {
        this.success = true
      }
    }
    
    // 心跳检测
    keepAlive() {
      setTimeout(() => {
        // 向服务器发送 ping 信号
        this.ws.send("ping")
        
        // 在 5s 内检测是否接收到 pong 信号
        setTimeout(() => {
          if (this.success) {
            this.success = false
            
            this.keepAlive() // 开始下一次心跳检测
          }
          else {
            this.ws.close() // 关闭 WebSocket
            
            this.reconnect() // 开始重连
          }
        }, this.HEART_CHECK_END_TIME)
      }, this.HEART_CHECK_TIME)
    }
    
    // 断线重连
    reconnect() {
      // 超过次数限制，就不重连了
      if (this.reconnectCount >= this.MAX_RECONNECT_COUNT) return
      
      clearTimeout(this.reconnectId)
      this.reconnectId = setTimeout(() => {
        this.reconnectCount++
        this.ws = this.initSocket()
      }, this.RECONNECT_TIME)
    }
  }
  
  export default function useSocket(url: string) {
    return new Socket(url)
  }
  ```

- 虚拟列表：

  假如有一万条数据需要处理，如果每条数据都生成一个元素，那么就会造成页面卡死。

  降采样策略：我们可以不用渲染全部数据，只渲染能看见的二十条数据，其他数据替换为一个空元素进行占位，这个空元素的大小与原本需要渲染的数据的大小相同。

  设置渲染数据范围：我们需要知道这二十条数据在总数据列表中的开始索引和结束索引，那么这个空元素的高度就是开始索引乘数据的高度。

  控制数据的变化：用平移来控制容器的滚动，每平移一条数据的高度，开始索引就加一，从而实现数据的滚动效果。

  ```vue
  <script setup lang="ts">
    import { ref, computed, onBeforeUnmount } from "vue"
    import useSocket from "./useSocket.ts"
    
    interface ItemType {
      id: string
      date: string
      address: string
      number: number
    }
    
    const virtualList = ref<ItemType[]>([])
    
    const startIndex = ref(0)
    const endIndex = ref(20)
    
    const realList = computed(() => virtualList.value.slice(startIndex.value, endIndex.value))
    
    const socket = useSocket("ws://localhost:8000")
    
    socket.onMessage((data: ItemType[]) => {
      virtualList.value = [...virtualList.value, ...data]
      
      start()
    })
    
    const top = ref(0)
    
    let timer: NodeJS.Timeout
    let isMouseEnter = false
    
    const start = () => {
      if (virtualList.value.length <= 23 || isMouseEnter) return
      
      clearInterval(timer)
      timer = setInterval(() => {
        top.value -= 0.6
        
        startIndex.value = Math.abs(Math.ceil(top.value / 30))
        endIndex.value = startIndex.value + 20
      }, 1000 / 60)
    }
    
    onBeforeUnmount(() => {
      clearInterval(timer)
    })
    
    const onEnter = () => {
      isMouseEnter = true
      clearInterval(timer)
    }
    
    const onLeave = () => {
      isMouseEnter = false
      start()
    }
  </script>
  
  <template>
    <div>
      <h3>需求人数</h3>
      
      <div class="container">
        <header class="row">
          <div>日期</div>
          <div>地址</div>
          <div>人数</div>
        </header>
        
        <main class="main" @mouseenter="onEnter" @mouseleave="onLeave">
          <div :style="{ transform: `translateY(${ top }px)` }">
            <div :style="{ height: startIndex * 30 + 'px' }"></div>
            
            <div class="row" v-for="{ id, date, address, number } in realList" :key="id">
              <div>{{ date }}</div>
              <div>{{ address }}</div>
              <div>{{ number }}</div>
            </div>
          </div>
        </main>
      </div>
    </div>
  </template>
  
  <style scoped>
    .container .main {
      overflow: hidden;
    }
    
    .container .main .row {
      height: 30px;
    }
  </style>
  ```

## 大屏适配

通过计算 scale 缩放系数完成适配。

当屏幕宽高比大于设计图宽高比，说明是宽屏，缩放系数为屏幕高度除以设计图高度；

当屏幕宽高比小于设计图宽高比，说明是竖屏，缩放系数为屏幕宽度除以设计图宽度。

```vue
<script setup lang="ts">
  import { ref, onMounted, onBeforeUnmount } from "vue"
  
  const scale = ref(1)
  
  const draftWidth = 1519
  const draftHeight = 747
  
  const resize = () => {
    const screenWidth = document.body.clientWidth
    const screenHeight = document.body.clientHeight
    
    if (screenWidth / screenHeight > draftWidth / draftHeight) {
      scale.value = screenHeight / draftHeight
    }
    else {
      scale.value = screenWidth / draftWidth
    }
  }
  
  onMounted(() => {
    resize()
    window.addEventListener("resize", resize)
  })
  
  onBeforeUnmount(() => {
    window.removeEventListener("resize", resize)
  })
</script>

<template>
  <div class="app">
    <div class="container" :style="{ transform: `scale(${ scale })` }"></div>
  </div>
</template>
```
